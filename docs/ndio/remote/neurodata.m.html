<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>ndio.remote.neurodata API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#ndio.remote.neurodata.DEFAULT_BLOCK_SIZE">DEFAULT_BLOCK_SIZE</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.DEFAULT_HOSTNAME">DEFAULT_HOSTNAME</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.DEFAULT_PROTOCOL">DEFAULT_PROTOCOL</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.DEFAULT_SUFFIX">DEFAULT_SUFFIX</a></li>
  </ul>

    </li>


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#ndio.remote.neurodata.neurodata">neurodata</a></span>
        
          
  <ul>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.__init__">__init__</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.add_subvolume">add_subvolume</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.create_channel">create_channel</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.delete_channel">delete_channel</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.delete_ramon">delete_ramon</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_block_size">get_block_size</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_channels">get_channels</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_cutout">get_cutout</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_image">get_image</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_image_offset">get_image_offset</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_image_size">get_image_size</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_metadata">get_metadata</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_proj_info">get_proj_info</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_propagate_status">get_propagate_status</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_public_datasets">get_public_datasets</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_public_datasets_and_tokens">get_public_datasets_and_tokens</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_public_tokens">get_public_tokens</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_ramon">get_ramon</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_ramon_bounding_box">get_ramon_bounding_box</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_ramon_ids">get_ramon_ids</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_ramon_metadata">get_ramon_metadata</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_subvolumes">get_subvolumes</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_token_dataset">get_token_dataset</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_volume">get_volume</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.get_xy_slice">get_xy_slice</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.merge_ids">merge_ids</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.meta_url">meta_url</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.ping">ping</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.post_cutout">post_cutout</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.post_ramon">post_ramon</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.propagate">propagate</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.reserve_ids">reserve_ids</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.set_metadata">set_metadata</a></li>
    <li class="mono"><a href="#ndio.remote.neurodata.neurodata.url">url</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">ndio.remote.neurodata</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata" class="source">
    <pre><code>from __future__ import absolute_import
import ndio
import requests
import os
import numpy
from io import BytesIO
import zlib
import tempfile
import blosc
import h5py

from .Remote import Remote
from .errors import *
import ndio.ramon as ramon
from six.moves import range
import six

from functools import wraps

try:
    import urllib.request as urllib2
except ImportError:
    import urllib2

DEFAULT_HOSTNAME = "openconnecto.me"
DEFAULT_SUFFIX = "ocp"
DEFAULT_PROTOCOL = "http"
DEFAULT_BLOCK_SIZE = (1024, 1024, 16)


class neurodata(Remote):
    """
    The NeuroData remote, for interfacing with ndstore, ndlims, and friends.
    """

    # SECTION:
    # Enumerables
    IMAGE = IMG = 'image'
    ANNOTATION = ANNO = 'annotation'

    def __init__(self,
                 hostname=DEFAULT_HOSTNAME,
                 protocol=DEFAULT_PROTOCOL,
                 meta_root="http://lims.neurodata.io/",
                 meta_protocol=DEFAULT_PROTOCOL, **kwargs):
        """
        Initializer for the neurodata remote class.

        Arguments:
            hostname (str: "openconnecto.me"): The hostname to connect to
            protocol (str: "http"): The protocol (http or https) to use
            meta_root (str: "http://lims.neurodata.io/"): The metadata server
            meta_protocol (str: "http"): The protocol to use for the md server
            check_tokens (boolean: False): Whether functions that take `token`
                as an argument should check for the existance of that token and
                fail immediately if it is not found. This is a good idea for
                functions that take more time to complete, and might not fail
                until the very end otherwise.
            chunk_threshold (int: 1e9 / 4): The maximum size of a numpy array
                that will be uploaded in one HTTP request. If you find that
                your data requests are commonly timing out, try reducing this.
                Default is 1e9 / 4, or a 0.25GiB.
            suffix (str: "ocp"): The URL suffix to specify ndstore/microns. If
                you aren't sure what to do with this, don't specify one.
        """
        self._check_tokens = kwargs.get('check_tokens', False)
        self._chunk_threshold = kwargs.get('chunk_threshold', 1E9 / 4)
        self._ext = kwargs.get('suffix', DEFAULT_SUFFIX)
        self._known_tokens = []

        # Prepare meta url
        self.meta_root = meta_root
        if not self.meta_root.endswith('/'):
            self.meta_root = self.meta_root + "/"
        if self.meta_root.startswith('http'):
            self.meta_root = self.meta_root[self.meta_root.index('://')+3:]
        self.meta_protocol = meta_protocol

        super(neurodata, self).__init__(hostname, protocol)

    # SECTION:
    # Decorators
    def _check_token(f):
        @wraps(f)
        def wrapped(self, *args, **kwargs):
            if self._check_tokens:
                if 'token' in kwargs:
                    token = kwargs['token']
                else:
                    token = args[0]
                if token not in self._known_tokens:
                    if self.ping('{}/info/'.format(token)) != 200:
                        raise RemoteDataNotFoundError("Bad token {}".format(
                                                      token))
                    else:
                        self._known_tokens.append(token)
            return f(self, *args, **kwargs)
        return wrapped

    # SECTION:
    # Utilities
    def ping(self, suffix='public_tokens/'):
        """
        Return the status-code of the API (estimated using the public-tokens
        lookup page).

        Arguments:
            suffix (str : 'public_tokens/'): The url endpoint to check

        Returns:
            int: status code
        """
        return super(neurodata, self).ping(suffix)

    def url(self, suffix=""):
        """
        Return a constructed URL, appending an optional suffix (uri path).

        Arguments:
            suffix (str : ""): The suffix to append to the end of the URL

        Returns:
            str: The complete URL
        """
        return super(neurodata, self).url('{}/ca/'.format(self._ext) + suffix)

    def meta_url(self, suffix=""):
        """
        Return a constructed URL, appending an optional suffix (uri path),
        for the metadata server. (Should be temporary, until the LIMS shim
        is fixed.)

        Arguments:
            suffix (str : ""): The suffix to append to the end of the URL

        Returns:
            str: The complete URL
        """
        return self.meta_protocol + "://" + self.meta_root + suffix

    def __repr__(self):
        """
        Return a string representation that can be used to reproduce this
        instance. `eval(repr(this))` should return an identical copy.

        Arguments:
            None

        Returns:
            str: Representation of reproducible instance.
        """
        return "ndio.remote.neurodata('{}', '{}')".format(
            self.hostname,
            self.protocol,
            self.meta_url,
            self.meta_protocol
        )

    # SECTION:
    # Metadata
    def get_public_tokens(self):
        """
        Get a list of public tokens available on this server.

        Arguments:
            None

        Returns:
            str[]: list of public tokens
        """
        r = requests.get(self.url() + "public_tokens/")
        return r.json()

    def get_public_datasets(self):
        """
        NOTE: VERY SLOW!
        Get a list of public datasets. Different than public tokens!

        Arguments:
            None

        Returns:
            str[]: list of public datasets
        """
        return list(self.get_public_datasets_and_tokens().keys())

    def get_public_datasets_and_tokens(self):
        """
        NOTE: VERY SLOW!
        Get a dictionary relating key:dataset to value:[tokens] that rely
        on that dataset.

        Arguments:
            None

        Returns:
            dict: relating key:dataset to value:[tokens]
        """
        datasets = {}
        tokens = self.get_public_tokens()
        for t in tokens:
            dataset = self.get_token_dataset(t)
            if dataset in datasets:
                datasets[dataset].append(t)
            else:
                datasets[dataset] = [t]
        return datasets

    @_check_token
    def get_token_dataset(self, token):
        """
        Get the dataset for a given token.

        Arguments:
            token (str): The token to inspect

        Returns:
            str: The name of the dataset
        """
        return self.get_proj_info(token)['dataset']['description']

    @_check_token
    def get_proj_info(self, token):
        """
        Return the project info for a given token.

        Arguments:
            token (str): Token to return information for

        Returns:
            JSON: representation of proj_info
        """
        r = requests.get(self.url() + "{}/info/".format(token))
        return r.json()

    @_check_token
    def get_metadata(self, token):
        """
        An alias for get_proj_info.
        """
        return self.get_proj_info(token)

    @_check_token
    def get_channels(self, token):
        """
        Wraps get_proj_info to return a dictionary of just the channels of
        a given project.

        Arguments:
            token (str): Token to return channels for

        Returns:
            JSON: dictionary of channels.
        """
        return self.get_proj_info(token)['channels']

    @_check_token
    def get_image_size(self, token, resolution=0):
        """
        Return the size of the volume (3D). Convenient for when you want
        to download the entirety of a dataset.

        Arguments:
            token (str): The token for which to find the dataset image bounds
            resolution (int : 0): The resolution at which to get image bounds.
                Defaults to 0, to get the largest area available.

        Returns:
            int[3]: The size of the bounds. Should == get_volume.shape

        Raises:
            RemoteDataNotFoundError: If the token is invalid, or if the
                metadata at that resolution is unavailable in projinfo.
        """
        info = self.get_proj_info(token)
        res = str(resolution)
        if res not in info['dataset']['imagesize']:
            raise RemoteDataNotFoundError("Resolution " + res +
                                          " is not available.")
        return info['dataset']['imagesize'][str(resolution)]

    @_check_token
    def set_metadata(self, token, data):
        """
        Insert new metadata into the OCP metadata database.

        Arguments:
            token (str): Token of the datum to set
            data (str): A dictionary to insert as metadata. Include `secret`.

        Returns:
            json: Info of the inserted ID (convenience) or an error message.

        Throws:
            RemoteDataUploadError: If the token is already populated, or if
                there is an issue with your specified `secret` key.
        """
        req = requests.post(self.meta_url("metadata/ocp/set/" + token),
                            json=data)

        if req.status_code != 200:
            raise RemoteDataUploadError(
                "Could not upload metadata: " + req.json()['message']
            )
        return req.json()

    @_check_token
    def get_subvolumes(self, token):
        """
        Return a list of subvolumes taken from LIMS, if available.

        Arguments:
            token (str): The token to read from in LIMS

        Returns:
            dict: or None if unavailable
        """
        md = self.get_metadata(token)['metadata']
        if 'subvolumes' in md:
            return md['subvolumes']
        else:
            return None

    @_check_token
    def add_subvolume(self, token, channel, secret,
                      x_start, x_stop,
                      y_start, y_stop,
                      z_start, z_stop,
                      resolution, title, notes):
        """
        Adds a new subvolume to a token/channel.

        Arguments:
            token (str): The token to write to in LIMS
            channel (str): Channel to add in the subvolume. Can be `None`
            x_start (int): Start in x dimension
            x_stop (int): Stop in x dimension
            y_start (int): Start in y dimension
            y_stop (int): Stop in y dimension
            z_start (int): Start in z dimension
            z_stop (int): Stop in z dimension
            resolution (int): The resolution at which this subvolume is seen
            title (str): The title to set for the subvolume
            notes (str): Optional extra thoughts on the subvolume

        Returns:
            boolean: success
        """
        md = self.get_metadata(token)['metadata']
        if 'subvolumes' in md:
            subvols = md['subvolumes']
        else:
            subvols = []

        subvols.append({
            'token': token,
            'channel': channel,
            'x_start': x_start,
            'x_stop': x_stop,
            'y_start': y_start,
            'y_stop': y_stop,
            'z_start': z_start,
            'z_stop': z_stop,
            'resolution': resolution,
            'title': title,
            'notes': notes
        })

        return self.set_metadata(token, {
            'secret': secret,
            'subvolumes': subvols
        })

    # SECTION:
    # Data Download
    @_check_token
    def get_block_size(self, token, resolution=None):
        """
        Gets the block-size for a given token at a given resolution.

        Arguments:
            token (str): The token to inspect
            resolution (int : None): The resolution at which to inspect data.
                If none is specified, uses the minimum available.

        Returns:
            int[3]: The xyz blocksize.
        """
        cdims = self.get_metadata(token)['dataset']['cube_dimension']
        if resolution is None:
            resolution = min(cdims.keys())
        return cdims[str(resolution)]

    @_check_token
    def get_image_offset(self, token, resolution=0):
        """
        Gets the image offset for a given token at a given resolution. For
        instance, the `kasthuri11` dataset starts at (0, 0, 1), so its 1850th
        slice is slice 1850, not 1849. When downloading a full dataset, the
        result of this function should be your x/y/z starts.

        Arguments:
            token (str): The token to inspect
            resolution (int : 0): The resolution at which to gather the offset

        Returns:
            int[3]: The origin of the dataset, as a list
        """
        info = self.get_proj_info(token)
        res = str(resolution)
        if res not in info['dataset']['offset']:
            raise RemoteDataNotFoundError("Resolution " + res +
                                          " is not available.")
        return info['dataset']['offset'][str(resolution)]

    @_check_token
    def get_xy_slice(self, token, channel,
                     x_start, x_stop,
                     y_start, y_stop,
                     z_index,
                     resolution=0):
        """
        Return a binary-encoded, decompressed 2d image. You should
        specify a 'token' and 'channel' pair.  For image data, users
        should use the channel 'image.'

        Arguments:
            token (str): Token to identify data to download
            channel (str): Channel
            resolution (int): Resolution level
            Q_start (int):` The lower bound of dimension 'Q'
            Q_stop (int): The upper bound of dimension 'Q'
            z_index (int): The z-slice to image

        Returns:
            str: binary image data
        """
        vol = self.get_cutout(token, channel, x_start, x_stop, y_start,
                              y_stop, z_index, z_index+1, resolution)

        vol = numpy.squeeze(vol)  # 3D volume to 2D slice

        return vol

    @_check_token
    def get_image(self, token, channel,
                  x_start, x_stop,
                  y_start, y_stop,
                  z_index,
                  resolution=0):
        """
        Alias for the `get_xy_slice` function for backwards compatibility.
        """
        return self.get_xy_slice(token, channel,
                                 x_start, x_stop,
                                 y_start, y_stop,
                                 z_index,
                                 resolution)

    @_check_token
    def get_volume(self, token, channel,
                   x_start, x_stop,
                   y_start, y_stop,
                   z_start, z_stop,
                   resolution=1,
                   block_size=DEFAULT_BLOCK_SIZE,
                   neariso=False):
        """
        Get a RAMONVolume volumetric cutout from the neurodata server.

        Arguments:
            token (str): Token to identify data to download
            channel (str): Channel
            resolution (int): Resolution level
            Q_start (int): The lower bound of dimension 'Q'
            Q_stop (int): The upper bound of dimension 'Q'
            block_size (int[3]): Block size of this dataset
            neariso (bool : False): Passes the 'neariso' param to the cutout.
                If you don't know what this means, ignore it!

        Returns:
            ndio.ramon.RAMONVolume: Downloaded data.
        """
        size = (x_stop-x_start)*(y_stop-y_start)*(z_stop-z_start)
        volume = ramon.RAMONVolume()
        volume.xyz_offset = [x_start, y_start, z_start]
        volume.resolution = resolution

        volume.cutout = self.get_cutout(token, channel, x_start,
                                        x_stop, y_start, y_stop,
                                        z_start, z_stop,
                                        resolution=resolution,
                                        block_size=block_size,
                                        neariso=neariso)
        return volume

    @_check_token
    def get_cutout(self, token, channel,
                   x_start, x_stop,
                   y_start, y_stop,
                   z_start, z_stop,
                   resolution=1,
                   block_size=DEFAULT_BLOCK_SIZE,
                   neariso=False):
        """
        Get volumetric cutout data from the neurodata server.

        Arguments:
            token (str): Token to identify data to download
            channel (str): Channel
            resolution (int): Resolution level
            Q_start (int): The lower bound of dimension 'Q'
            Q_stop (int): The upper bound of dimension 'Q'
            block_size (int[3]): Block size of this dataset. If not provided,
                ndio uses the metadata of this tokenchannel to set. If you find
                that your downloads are timing out or otherwise failing, it may
                be wise to start off by making this smaller.
            neariso (bool : False): Passes the 'neariso' param to the cutout.
                If you don't know what this means, ignore it!

        Returns:
            numpy.ndarray: Downloaded data.
        """
        if block_size is None:
            # look up block size from metadata
            block_size = self.get_block_size(token, resolution)

        origin = self.get_image_offset(token, resolution)

        # If z_stop - z_start is < 16, backend still pulls minimum 16 slices
        if (z_stop - z_start) < 16:
            z_slices = 16
        else:
            z_slices = z_stop - z_start

        # Calculate size of the data to be downloaded.
        size = (x_stop - x_start) * (y_stop - y_start) * z_slices * 4

        # Switch which download function to use based on which libraries are
        # available in this version of python.
        if six.PY2:
            dl_func = self._get_cutout_blosc_no_chunking
        elif six.PY3:
            dl_func = self._get_cutout_no_chunking
        else:
            raise ValueError("Invalid Python version.")

        if size < self._chunk_threshold:
            vol = dl_func(token, channel, resolution,
                          x_start, x_stop,
                          y_start, y_stop,
                          z_start, z_stop, neariso=neariso)
            vol = numpy.rollaxis(vol, 1)
            vol = numpy.rollaxis(vol, 2)
            return vol
        else:
            from ndio.utils.parallel import block_compute
            blocks = block_compute(x_start, x_stop,
                                   y_start, y_stop,
                                   z_start, z_stop,
                                   origin, block_size)

            vol = numpy.zeros(((z_stop - z_start),
                              (y_stop - y_start),
                              (x_stop - x_start)))
            for b in blocks:

                data = dl_func(token, channel, resolution,
                               b[0][0], b[0][1],
                               b[1][0], b[1][1],
                               b[2][0], b[2][1], neariso=neariso)

                if b == blocks[0]:  # first block
                    vol = numpy.zeros(((z_stop - z_start),
                                       (y_stop - y_start),
                                       (x_stop - x_start)), dtype=data.dtype)

                vol[b[2][0]-z_start: b[2][1]-z_start,
                    b[1][0]-y_start: b[1][1]-y_start,
                    b[0][0]-x_start: b[0][1]-x_start] = data

            vol = numpy.rollaxis(vol, 1)
            vol = numpy.rollaxis(vol, 2)
            return vol

    def _get_cutout_no_chunking(self, token, channel, resolution,
                                x_start, x_stop, y_start, y_stop,
                                z_start, z_stop, neariso=False):
        url = self.url() + "{}/{}/hdf5/{}/{},{}/{},{}/{},{}/".format(
           token, channel, resolution,
           x_start, x_stop,
           y_start, y_stop,
           z_start, z_stop
        )

        if neariso:
            url += "neariso/"

        req = requests.get(url)
        if req.status_code is not 200:
            raise IOError("Bad server response for {}: {}: {}".format(
                          url,
                          req.status_code,
                          req.text))

        with tempfile.NamedTemporaryFile() as tmpfile:
            tmpfile.write(req.content)
            tmpfile.seek(0)
            h5file = h5py.File(tmpfile.name, "r")
            return h5file.get(channel).get('CUTOUT')[:]
        raise IOError("Failed to make tempfile.")

    def _get_cutout_blosc_no_chunking(self, token, channel, resolution,
                                      x_start, x_stop, y_start, y_stop,
                                      z_start, z_stop, neariso=False):

        url = self.url() + "{}/{}/blosc/{}/{},{}/{},{}/{},{}/".format(
           token, channel, resolution,
           x_start, x_stop,
           y_start, y_stop,
           z_start, z_stop
        )

        if neariso:
            url += "neariso/"

        req = requests.get(url)
        if req.status_code is not 200:
            raise IOError("Bad server response for {}: {}: {}".format(
                          url,
                          req.status_code,
                          req.text))

        # This will need modification for >3D blocks
        return blosc.unpack_array(req.content)[0]

        raise IOError("Failed to retrieve blosc cutout.")

    # SECTION:
    # Data Upload

    @_check_token
    def post_cutout(self, token, channel,
                    x_start,
                    y_start,
                    z_start,
                    data,
                    resolution=0):
        """
        Post a cutout to the server.

        Arguments:
            token (str)
            channel (str)
            x_start (int)
            y_start (int)
            z_start (int)
            data (numpy.ndarray): A numpy array of data. Pass in (x, y, z)
            resolution (int : 0): Resolution at which to insert the data

        Returns:
            bool: True on success

        Raises:
            RemoteDataUploadError: if there's an issue during upload.
        """
        datatype = self.get_proj_info(token)['channels'][channel]['datatype']
        if data.dtype.name != datatype:
            data = data.astype(datatype)

        data = numpy.rollaxis(data, 1)
        data = numpy.rollaxis(data, 2)

        if six.PY3 or data.nbytes > 1.5e9:
            ul_func = self._post_cutout_no_chunking_npz
        else:
            ul_func = self._post_cutout_no_chunking_blosc

        if data.size < self._chunk_threshold:
            return ul_func(token, channel, x_start,
                           y_start, z_start, data,
                           resolution)

        return self._post_cutout_with_chunking(token, channel,
                                               x_start, y_start, z_start, data,
                                               resolution, ul_func)

    def _post_cutout_with_chunking(self, token, channel, x_start,
                                   y_start, z_start, data,
                                   resolution, ul_func):
        # must chunk first
        from ndio.utils.parallel import block_compute
        blocks = block_compute(x_start, x_start + data.shape[2],
                               y_start, y_start + data.shape[1],
                               z_start, z_start + data.shape[0])
        for b in blocks:
            # data coordinate relative to the size of the arra
            subvol = data[b[2][0]-z_start: b[2][1]-z_start,
                          b[1][0]-y_start: b[1][1]-y_start,
                          b[0][0]-x_start: b[0][1]-x_start]
            # upload the chunk:
            # upload coordinate relative to x_start, y_start, z_start
            ul_func(token, channel, b[0][0],
                    b[1][0], b[2][0], subvol,
                    resolution)
        return True

    def _post_cutout_no_chunking_npz(self, token, channel,
                                     x_start, y_start, z_start,
                                     data, resolution):

        data = numpy.expand_dims(data, axis=0)
        tempfile = BytesIO()
        numpy.save(tempfile, data)
        compressed = zlib.compress(tempfile.getvalue())

        url = self.url("{}/{}/npz/{}/{},{}/{},{}/{},{}/".format(
            token, channel,
            resolution,
            x_start, x_start + data.shape[3],
            y_start, y_start + data.shape[2],
            z_start, z_start + data.shape[1]
        ))

        req = requests.post(url, data=compressed, headers={
            'Content-Type': 'application/octet-stream'
        })

        if req.status_code is not 200:
            raise RemoteDataUploadError(req.text)
        else:
            return True

    def _post_cutout_no_chunking_blosc(self, token, channel,
                                       x_start, y_start, z_start,
                                       data, resolution):
        """
        Accepts data in zyx. !!!
        """
        data = numpy.expand_dims(data, axis=0)
        blosc_data = blosc.pack_array(data)

        url = self.url("{}/{}/blosc/{}/{},{}/{},{}/{},{}/".format(
            token, channel,
            resolution,
            x_start, x_start + data.shape[3],
            y_start, y_start + data.shape[2],
            z_start, z_start + data.shape[1]
        ))
        req = requests.post(url, data=blosc_data, headers={
            'Content-Type': 'application/octet-stream'
        })

        if req.status_code is not 200:
            raise RemoteDataUploadError(req.text)
        else:
            return True

    # SECTION:
    # RAMON Download

    @_check_token
    def get_ramon_bounding_box(self, token, channel, r_id, resolution=0):
        """
        Get the bounding box for a RAMON object (specified by ID).

        Arguments:
            token (str): Project to use
            channel (str): Channel to use
            r_id (int): Which ID to get a bounding box
            resolution (int : 0): The resolution at which to download

        Returns:
            (x_start, x_stop, y_start, y_stop, z_start, z_stop): ints
        """
        url = self.url('{}/{}/{}/boundingbox/{}/'.format(token, channel,
                                                         r_id, resolution))

        r_id = str(r_id)
        res = requests.get(url)

        if res.status_code != 200:
            rt = self.get_ramon_metadata(token, channel, r_id)[r_id]['type']
            if rt in ['neuron']:
                raise ValueError("ID {} is of type '{}'".format(r_id, rt))
            raise RemoteDataNotFoundError("No such ID {}".format(r_id))

        with tempfile.NamedTemporaryFile() as tmpfile:
            tmpfile.write(res.content)
            tmpfile.seek(0)
            h5file = h5py.File(tmpfile.name, "r")
            origin = h5file["{}/XYZOFFSET".format(r_id)][()]
            size = h5file["{}/XYZDIMENSION".format(r_id)][()]
            return (origin[0], origin[0] + size[0],
                    origin[1], origin[1] + size[1],
                    origin[2], origin[2] + size[2])

    @_check_token
    def get_ramon_ids(self, token, channel, ramon_type=None):
        """
        Return a list of all IDs available for download from this token and
        channel.

        Arguments:
            token (str): Project to use
            channel (str): Channel to use
            ramon_type (int : None): Optional. If set, filters IDs and only
                returns those of RAMON objects of the requested type.

        Returns:
            int[]: A list of the ids of the returned RAMON objects

        Raises:
            RemoteDataNotFoundError: If the channel or token is not found
        """
        url = self.url("{}/{}/query/".format(token, channel))
        if ramon_type is not None:
            # User is requesting a specific ramon_type.
            if type(ramon_type) is not int:
                ramon_type = ramon.AnnotationType.get_int(ramon_type)
            url += "type/{}/".format(str(ramon_type))

        req = requests.get(url)

        if req.status_code is not 200:
            raise RemoteDataNotFoundError('No query results for token {}.'
                                          .format(token))
        else:
            with tempfile.NamedTemporaryFile() as tmpfile:
                tmpfile.write(req.content)
                tmpfile.seek(0)
                h5file = h5py.File(tmpfile.name, "r")
                if 'ANNOIDS' not in h5file:
                    return []
                return [i for i in h5file['ANNOIDS']]
            raise IOError("Could not successfully mock HDF5 file for parsing.")

    @_check_token
    def get_ramon(self, token, channel, ids, resolution=0,
                  include_cutout=False, sieve=None, batch_size=100):
        """
        Download a RAMON object by ID.

        Arguments:
            token (str): Project to use
            channel (str): The channel to use
            ids (int, str, int[], str[]): The IDs of a RAMON object to gather.
                Can be int (3), string ("3"), int[] ([3, 4, 5]), or string
                (["3", "4", "5"]).
            resolution (int : None): Resolution. Defaults to the most granular
                resolution (0 for now)
            include_cutout (bool : False):  If True, r.cutout is populated
            sieve (function : None): A function that accepts a single ramon
                and returns True or False depending on whether you want that
                ramon object to be included in your response or not.
                For example,
                ```
                def is_even_id(ramon):
                    return ramon.id % 2 == 0
                ```
                You can then pass this to get_ramon like this:
                ```
                ndio.remote.neurodata.get_ramon( . . . , sieve=is_even_id)
                ```
            batch_size (int : 100): The amount of RAMON objects to download at
                a time. If this is greater than 100, we anticipate things going
                very poorly for you. So if you set it <100, ndio will use it.
                If >=100, set it to 100.

        Returns:
            ndio.ramon.RAMON[]: A list of returned RAMON objects.

        Raises:
            RemoteDataNotFoundError: If the requested ids cannot be found.
        """
        b_size = min(100, batch_size)

        _return_first_only = False
        if type(ids) is not list:
            _return_first_only = True
            ids = [ids]
        ids = [str(i) for i in ids]

        rs = []
        id_batches = [ids[i:i+b_size] for i in range(0, len(ids), b_size)]
        for batch in id_batches:
            rs.extend(self._get_ramon_batch(token, channel, batch, resolution))

        rs = self._filter_ramon(rs, sieve)

                # if 'cutout' not in dir(ramon):
                #     return ramon
        if include_cutout:
            rs = [self._add_ramon_cutout(token, channel, r, resolution)
                  for r in rs]

        if _return_first_only:
            return rs[0]

        return sorted(rs, key=lambda x: ids.index(x.id))

    def _filter_ramon(self, rs, sieve):
        if sieve is not None:
            return [r for r in rs if sieve(r)]
        return rs

    def _add_ramon_cutout(self, token, channel, ramon, resolution):
        origin = ramon.xyz_offset
        # Get the bounding box (cube-aligned)
        bbox = self.get_ramon_bounding_box(token, channel,
                                           ramon.id, resolution=resolution)
        # Get the cutout (cube-aligned)
        cutout = self.get_cutout(token, channel,
                                 *bbox, resolution=resolution)
        cutout[cutout != int(ramon.id)] = 0

        # Compute upper offset and crop
        bounds = numpy.argwhere(cutout)
        mins = [min([i[dim] for i in bounds]) for dim in range(3)]
        maxs = [max([i[dim] for i in bounds]) for dim in range(3)]

        ramon.cutout = cutout[
            mins[0]:maxs[0],
            mins[1]:maxs[1],
            mins[2]:maxs[2]
        ]

        return ramon

    def _get_ramon_batch(self, token, channel, ids, resolution):
        ids = [str(i) for i in ids]
        url = self.url("{}/{}/{}/json/".format(token, channel, ",".join(ids)))
        req = requests.get(url)

        if req.status_code is not 200:
            raise RemoteDataNotFoundError('No data for id {}.'.format(ids))
        else:
            return ramon.from_json(req.json())

    @_check_token
    def get_ramon_metadata(self, token, channel, anno_id):
        """
        Download a RAMON object by ID. `anno_id` can be a string `"123"`, an
        int `123`, an array of ints `[123, 234, 345]`, an array of strings
        `["123", "234", "345"]`, or a comma-separated string list
        `"123,234,345"`.

        Arguments:
            token (str): Project to use
            channel (str): The channel to use
            anno_id: An int, a str, or a list of ids to gather

        Returns:
            JSON. If you pass a single id in str or int, returns a single datum
            If you pass a list of int or str or a comma-separated string, will
            return a dict with keys from the list and the values are the JSON
            returned from the server.

        Raises:
            RemoteDataNotFoundError: If the data cannot be found on the Remote
        """
        if type(anno_id) in [int, numpy.uint32]:
            # there's just one ID to download
            return self._get_single_ramon_metadata(token, channel,
                                                   str(anno_id))
        elif type(anno_id) is str:
            # either "id" or "id,id,id":
            if (len(anno_id.split(',')) > 1):
                results = {}
                for i in anno_id.split(','):
                    results[i] = self._get_single_ramon_metadata(
                        token, channel, anno_id.strip()
                    )
                return results
            else:
                # "id"
                return self._get_single_ramon_metadata(token, channel,
                                                       anno_id.strip())
        elif type(anno_id) is list:
            # [id, id] or ['id', 'id']
            results = []
            for i in anno_id:
                results.append(self._get_single_ramon_metadata(token, channel,
                                                               str(i)))
            return results

    def _get_single_ramon_metadata(self, token, channel, anno_id):
        req = requests.get(self.url() +
                           "{}/{}/{}/json/".format(token, channel, anno_id))
        if req.status_code is not 200:
            raise RemoteDataNotFoundError('No data for id {}.'.format(anno_id))
        return req.json()

    @_check_token
    def delete_ramon(self, token, channel, anno):
        """
        Deletes an annotation from the server. Probably you should be careful
        with this function, it seems dangerous.

        Arguments:
            token (str): The token to inspect
            channel (str): The channel to inspect
            anno (int OR list(int) OR RAMON): The annotation to delete. If a
                RAMON object is supplied, the remote annotation will be deleted
                by an ID lookup. If an int is supplied, the annotation will be
                deleted for that ID. If a list of ints are provided, they will
                all be deleted.

        Returns:
            bool: Success
        """
        if type(anno) is int:
            a = anno
        if type(anno) is str:
            a = int(anno)
        if type(anno) is list:
            a = ",".join(anno)
        else:
            a = anno.id

        req = requests.delete(self.url("{}/{}/{}/".format(token, channel, a)))
        if req.status_code is not 200:
            raise RemoteDataNotFoundError("Could not delete id {}: {}"
                                          .format(a, req.text))
        else:
            return True

    @_check_token
    def post_ramon(self, token, channel, r, batch_size=100):
        """
        Posts a RAMON object to the Remote.

        Arguments:
            token (str): Project to use
            channel (str): The channel to use
            r (RAMON or RAMON[]): The annotation(s) to upload
            batch_size (int : 100): The number of RAMONs to post simultaneously
                at maximum in one file. If len(r) > batch_size, the batch will
                be split and uploaded automatically. Must be less than 100.

        Returns:
            bool: Success = True

        Throws:
            RemoteDataUploadError: if something goes wrong
        """
        # Max out batch-size at 100.
        b_size = min(100, batch_size)

        # Coerce incoming IDs to a list.
        if type(r) is not list:
            r = [r]

        # If there are too many to fit in one batch, split here and call this
        # function recursively.
        if len(r) > batch_size:
            batches = [r[i:i+b_size] for i in range(0, len(r), b_size)]
            for batch in batches:
                self.post_ramon(token, channel, batch, b_size)
            return

        with tempfile.NamedTemporaryFile(delete=False) as tmpfile:
            for i in r:
                tmpfile = ramon.to_hdf5(i, tmpfile)

            url = self.url("{}/{}/overwrite/".format(token, channel))
            req = urllib2.Request(url, tmpfile.read())
            res = urllib2.urlopen(req)

            if res.code != 200:
                raise RemoteDataUploadError('[{}] Could not upload {}'
                                            .format(res.code, str(r)))

            rets = res.read()
            if six.PY3:
                rets = rets.decode()
            return_ids = [int(rid) for rid in rets.split(',')]

            # Now post the cutout separately:
            for ri in r:
                if 'cutout' in dir(ri) and ri.cutout is not None:
                    orig = ri.xyz_offset
                    self.post_cutout(token, channel,
                                     orig[0], orig[1], orig[2],
                                     ri.cutout, resolution=r.resolution)
            return return_ids
        return True

    # SECTION:
    # ID Manipulation

    @_check_token
    def reserve_ids(self, token, channel, quantity):
        """
        Requests a list of next-available-IDs from the server.

        Arguments:
            quantity (int): The number of IDs to reserve

        Returns:
            int[quantity]: List of IDs you've been granted
        """
        quantity = str(quantity)
        url = self.url("{}/{}/reserve/{}/".format(token, channel, quantity))
        req = requests.get(url)
        if req.status_code is not 200:
            raise RemoteDataNotFoundError('Invalid req: ' + req.status_code)
        out = req.json()
        return [out[0] + i for i in range(out[1])]

    @_check_token
    def merge_ids(self, token, channel, ids, delete=False):
        """
        Call the restful endpoint to merge two RAMON objects into one.

        Arguments:
            token (str): The token to inspect
            channel (str): The channel to inspect
            ids (int[]): the list of the IDs to merge
            delete (bool : False): Whether to delete after merging.

        Returns:
            json: The ID as returned by ndstore
        """
        req = requests.get(self.url() + "/merge/{}/"
                           .format(','.join([str(i) for i in ids])))
        if req.status_code is not 200:
            raise RemoteDataUploadError('Could not merge ids {}'.format(
                                        ','.join([str(i) for i in ids])))
        if delete:
            self.delete_ramon(token, channel, ids[1:])
        return True

    # SECTION:
    # Channels

    def _check_channel(self, channel):
        for c in channel:
            if not c.isalnum():
                raise ValueError(
                    "Channel name cannot contain character {}.".format(c)
                )
        return True

    @_check_token
    def create_channel(self, token, name, channel_type, dtype, readonly):
        """
        Create a new channel on the Remote, using channel_data.

        Arguments:
            token (str): The token the new channel should be added to
            name (str): The name of the channel to add
            channel_type (str): Type of the channel (e.g. `neurodata.IMAGE`)
            dtype (str): The datatype of the channel's data (e.g. `uint8`)
            readonly (bool): Can others write to this channel?

        Returns:
            bool: `True` if successful, `False` otherwise.

        Raises:
            ValueError: If your args were bad :(
            RemoteDataUploadError: If the channel data is valid but upload
                fails for some other reason.
        """
        self._check_channel(name)

        if channel_type not in ['image', 'annotation']:
            raise ValueError('Channel type must be ' +
                             'neurodata.IMAGE or neurodata.ANNOTATION.')

        if readonly * 1 not in [0, 1]:
            raise ValueError("readonly must be 0 (False) or 1 (True).")

        # Good job! You supplied very nice arguments.
        req = requests.post(self.url("{}/createChannel/".format(token)), json={
            "channels": {
                name: {
                    "channel_name": name,
                    "channel_type": channel_type,
                    "datatype": dtype,
                    "readonly": readonly * 1
                }
            }
        })

        if req.status_code is not 200:
            raise RemoteDataUploadError('Could not upload {}'.format(req.text))
        else:
            return True

    @_check_token
    def delete_channel(self, token, name):
        """
        Delete an existing channel on the Remote. Be careful!

        Arguments:
            token (str): The token the new channel should be deleted from
            name (str): The name of the channel to delete

        Returns:
            bool: True if successful, False otherwise.

        Raises:
            RemoteDataUploadError: If the upload fails for some reason.
        """
        req = requests.post(self.url("{}/deleteChannel/".format(token)), json={
            "channels": [name]
        })

        if req.status_code is not 200:
            raise RemoteDataUploadError('Could not delete {}'.format(req.text))
        if req.content == "SUCCESS":
            return True
        else:
            return False

    # Propagation

    @_check_token
    def propagate(self, token, channel):
        """
        Kick off the propagate function on the remote server.

        Arguments:
            token (str): The token to propagate
            channel (str): The channel to propagate

        Returns:
            boolean: Success
        """
        if self.get_propagate_status(token, channel) is not 0:
            return
        url = self.url('{}/{}/setPropagate/1/'.format(token, channel))
        req = requests.get(url)
        if req.status_code is not 200:
            raise RemoteDataUploadError('Propagate fail: {}'.format(req.text))
        return True

    @_check_token
    def get_propagate_status(self, token, channel):
        """
        Get the propagate status for a token/channel pair.

        Arguments:
            token (str): The token to check
            channel (str): The channel to check

        Returns:
            str: The status code
        """
        url = self.url('{}/{}/getPropagate/'.format(token, channel))
        req = requests.get(url)
        if req.status_code is not 200:
            raise ValueError('Bad pair: {}/{}'.format(token, channel))
        return req.text
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="ndio.remote.neurodata.DEFAULT_BLOCK_SIZE" class="name">var <span class="ident">DEFAULT_BLOCK_SIZE</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="ndio.remote.neurodata.DEFAULT_HOSTNAME" class="name">var <span class="ident">DEFAULT_HOSTNAME</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="ndio.remote.neurodata.DEFAULT_PROTOCOL" class="name">var <span class="ident">DEFAULT_PROTOCOL</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="ndio.remote.neurodata.DEFAULT_SUFFIX" class="name">var <span class="ident">DEFAULT_SUFFIX</span></p>
      
  
  <div class="source_cont">
</div>

      </div>


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="ndio.remote.neurodata.neurodata" class="name">class <span class="ident">neurodata</span></p>
      
  
    <div class="desc"><p>The NeuroData remote, for interfacing with ndstore, ndlims, and friends.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata" class="source">
    <pre><code>class neurodata(Remote):
    """
    The NeuroData remote, for interfacing with ndstore, ndlims, and friends.
    """

    # SECTION:
    # Enumerables
    IMAGE = IMG = 'image'
    ANNOTATION = ANNO = 'annotation'

    def __init__(self,
                 hostname=DEFAULT_HOSTNAME,
                 protocol=DEFAULT_PROTOCOL,
                 meta_root="http://lims.neurodata.io/",
                 meta_protocol=DEFAULT_PROTOCOL, **kwargs):
        """
        Initializer for the neurodata remote class.

        Arguments:
            hostname (str: "openconnecto.me"): The hostname to connect to
            protocol (str: "http"): The protocol (http or https) to use
            meta_root (str: "http://lims.neurodata.io/"): The metadata server
            meta_protocol (str: "http"): The protocol to use for the md server
            check_tokens (boolean: False): Whether functions that take `token`
                as an argument should check for the existance of that token and
                fail immediately if it is not found. This is a good idea for
                functions that take more time to complete, and might not fail
                until the very end otherwise.
            chunk_threshold (int: 1e9 / 4): The maximum size of a numpy array
                that will be uploaded in one HTTP request. If you find that
                your data requests are commonly timing out, try reducing this.
                Default is 1e9 / 4, or a 0.25GiB.
            suffix (str: "ocp"): The URL suffix to specify ndstore/microns. If
                you aren't sure what to do with this, don't specify one.
        """
        self._check_tokens = kwargs.get('check_tokens', False)
        self._chunk_threshold = kwargs.get('chunk_threshold', 1E9 / 4)
        self._ext = kwargs.get('suffix', DEFAULT_SUFFIX)
        self._known_tokens = []

        # Prepare meta url
        self.meta_root = meta_root
        if not self.meta_root.endswith('/'):
            self.meta_root = self.meta_root + "/"
        if self.meta_root.startswith('http'):
            self.meta_root = self.meta_root[self.meta_root.index('://')+3:]
        self.meta_protocol = meta_protocol

        super(neurodata, self).__init__(hostname, protocol)

    # SECTION:
    # Decorators
    def _check_token(f):
        @wraps(f)
        def wrapped(self, *args, **kwargs):
            if self._check_tokens:
                if 'token' in kwargs:
                    token = kwargs['token']
                else:
                    token = args[0]
                if token not in self._known_tokens:
                    if self.ping('{}/info/'.format(token)) != 200:
                        raise RemoteDataNotFoundError("Bad token {}".format(
                                                      token))
                    else:
                        self._known_tokens.append(token)
            return f(self, *args, **kwargs)
        return wrapped

    # SECTION:
    # Utilities
    def ping(self, suffix='public_tokens/'):
        """
        Return the status-code of the API (estimated using the public-tokens
        lookup page).

        Arguments:
            suffix (str : 'public_tokens/'): The url endpoint to check

        Returns:
            int: status code
        """
        return super(neurodata, self).ping(suffix)

    def url(self, suffix=""):
        """
        Return a constructed URL, appending an optional suffix (uri path).

        Arguments:
            suffix (str : ""): The suffix to append to the end of the URL

        Returns:
            str: The complete URL
        """
        return super(neurodata, self).url('{}/ca/'.format(self._ext) + suffix)

    def meta_url(self, suffix=""):
        """
        Return a constructed URL, appending an optional suffix (uri path),
        for the metadata server. (Should be temporary, until the LIMS shim
        is fixed.)

        Arguments:
            suffix (str : ""): The suffix to append to the end of the URL

        Returns:
            str: The complete URL
        """
        return self.meta_protocol + "://" + self.meta_root + suffix

    def __repr__(self):
        """
        Return a string representation that can be used to reproduce this
        instance. `eval(repr(this))` should return an identical copy.

        Arguments:
            None

        Returns:
            str: Representation of reproducible instance.
        """
        return "ndio.remote.neurodata('{}', '{}')".format(
            self.hostname,
            self.protocol,
            self.meta_url,
            self.meta_protocol
        )

    # SECTION:
    # Metadata
    def get_public_tokens(self):
        """
        Get a list of public tokens available on this server.

        Arguments:
            None

        Returns:
            str[]: list of public tokens
        """
        r = requests.get(self.url() + "public_tokens/")
        return r.json()

    def get_public_datasets(self):
        """
        NOTE: VERY SLOW!
        Get a list of public datasets. Different than public tokens!

        Arguments:
            None

        Returns:
            str[]: list of public datasets
        """
        return list(self.get_public_datasets_and_tokens().keys())

    def get_public_datasets_and_tokens(self):
        """
        NOTE: VERY SLOW!
        Get a dictionary relating key:dataset to value:[tokens] that rely
        on that dataset.

        Arguments:
            None

        Returns:
            dict: relating key:dataset to value:[tokens]
        """
        datasets = {}
        tokens = self.get_public_tokens()
        for t in tokens:
            dataset = self.get_token_dataset(t)
            if dataset in datasets:
                datasets[dataset].append(t)
            else:
                datasets[dataset] = [t]
        return datasets

    @_check_token
    def get_token_dataset(self, token):
        """
        Get the dataset for a given token.

        Arguments:
            token (str): The token to inspect

        Returns:
            str: The name of the dataset
        """
        return self.get_proj_info(token)['dataset']['description']

    @_check_token
    def get_proj_info(self, token):
        """
        Return the project info for a given token.

        Arguments:
            token (str): Token to return information for

        Returns:
            JSON: representation of proj_info
        """
        r = requests.get(self.url() + "{}/info/".format(token))
        return r.json()

    @_check_token
    def get_metadata(self, token):
        """
        An alias for get_proj_info.
        """
        return self.get_proj_info(token)

    @_check_token
    def get_channels(self, token):
        """
        Wraps get_proj_info to return a dictionary of just the channels of
        a given project.

        Arguments:
            token (str): Token to return channels for

        Returns:
            JSON: dictionary of channels.
        """
        return self.get_proj_info(token)['channels']

    @_check_token
    def get_image_size(self, token, resolution=0):
        """
        Return the size of the volume (3D). Convenient for when you want
        to download the entirety of a dataset.

        Arguments:
            token (str): The token for which to find the dataset image bounds
            resolution (int : 0): The resolution at which to get image bounds.
                Defaults to 0, to get the largest area available.

        Returns:
            int[3]: The size of the bounds. Should == get_volume.shape

        Raises:
            RemoteDataNotFoundError: If the token is invalid, or if the
                metadata at that resolution is unavailable in projinfo.
        """
        info = self.get_proj_info(token)
        res = str(resolution)
        if res not in info['dataset']['imagesize']:
            raise RemoteDataNotFoundError("Resolution " + res +
                                          " is not available.")
        return info['dataset']['imagesize'][str(resolution)]

    @_check_token
    def set_metadata(self, token, data):
        """
        Insert new metadata into the OCP metadata database.

        Arguments:
            token (str): Token of the datum to set
            data (str): A dictionary to insert as metadata. Include `secret`.

        Returns:
            json: Info of the inserted ID (convenience) or an error message.

        Throws:
            RemoteDataUploadError: If the token is already populated, or if
                there is an issue with your specified `secret` key.
        """
        req = requests.post(self.meta_url("metadata/ocp/set/" + token),
                            json=data)

        if req.status_code != 200:
            raise RemoteDataUploadError(
                "Could not upload metadata: " + req.json()['message']
            )
        return req.json()

    @_check_token
    def get_subvolumes(self, token):
        """
        Return a list of subvolumes taken from LIMS, if available.

        Arguments:
            token (str): The token to read from in LIMS

        Returns:
            dict: or None if unavailable
        """
        md = self.get_metadata(token)['metadata']
        if 'subvolumes' in md:
            return md['subvolumes']
        else:
            return None

    @_check_token
    def add_subvolume(self, token, channel, secret,
                      x_start, x_stop,
                      y_start, y_stop,
                      z_start, z_stop,
                      resolution, title, notes):
        """
        Adds a new subvolume to a token/channel.

        Arguments:
            token (str): The token to write to in LIMS
            channel (str): Channel to add in the subvolume. Can be `None`
            x_start (int): Start in x dimension
            x_stop (int): Stop in x dimension
            y_start (int): Start in y dimension
            y_stop (int): Stop in y dimension
            z_start (int): Start in z dimension
            z_stop (int): Stop in z dimension
            resolution (int): The resolution at which this subvolume is seen
            title (str): The title to set for the subvolume
            notes (str): Optional extra thoughts on the subvolume

        Returns:
            boolean: success
        """
        md = self.get_metadata(token)['metadata']
        if 'subvolumes' in md:
            subvols = md['subvolumes']
        else:
            subvols = []

        subvols.append({
            'token': token,
            'channel': channel,
            'x_start': x_start,
            'x_stop': x_stop,
            'y_start': y_start,
            'y_stop': y_stop,
            'z_start': z_start,
            'z_stop': z_stop,
            'resolution': resolution,
            'title': title,
            'notes': notes
        })

        return self.set_metadata(token, {
            'secret': secret,
            'subvolumes': subvols
        })

    # SECTION:
    # Data Download
    @_check_token
    def get_block_size(self, token, resolution=None):
        """
        Gets the block-size for a given token at a given resolution.

        Arguments:
            token (str): The token to inspect
            resolution (int : None): The resolution at which to inspect data.
                If none is specified, uses the minimum available.

        Returns:
            int[3]: The xyz blocksize.
        """
        cdims = self.get_metadata(token)['dataset']['cube_dimension']
        if resolution is None:
            resolution = min(cdims.keys())
        return cdims[str(resolution)]

    @_check_token
    def get_image_offset(self, token, resolution=0):
        """
        Gets the image offset for a given token at a given resolution. For
        instance, the `kasthuri11` dataset starts at (0, 0, 1), so its 1850th
        slice is slice 1850, not 1849. When downloading a full dataset, the
        result of this function should be your x/y/z starts.

        Arguments:
            token (str): The token to inspect
            resolution (int : 0): The resolution at which to gather the offset

        Returns:
            int[3]: The origin of the dataset, as a list
        """
        info = self.get_proj_info(token)
        res = str(resolution)
        if res not in info['dataset']['offset']:
            raise RemoteDataNotFoundError("Resolution " + res +
                                          " is not available.")
        return info['dataset']['offset'][str(resolution)]

    @_check_token
    def get_xy_slice(self, token, channel,
                     x_start, x_stop,
                     y_start, y_stop,
                     z_index,
                     resolution=0):
        """
        Return a binary-encoded, decompressed 2d image. You should
        specify a 'token' and 'channel' pair.  For image data, users
        should use the channel 'image.'

        Arguments:
            token (str): Token to identify data to download
            channel (str): Channel
            resolution (int): Resolution level
            Q_start (int):` The lower bound of dimension 'Q'
            Q_stop (int): The upper bound of dimension 'Q'
            z_index (int): The z-slice to image

        Returns:
            str: binary image data
        """
        vol = self.get_cutout(token, channel, x_start, x_stop, y_start,
                              y_stop, z_index, z_index+1, resolution)

        vol = numpy.squeeze(vol)  # 3D volume to 2D slice

        return vol

    @_check_token
    def get_image(self, token, channel,
                  x_start, x_stop,
                  y_start, y_stop,
                  z_index,
                  resolution=0):
        """
        Alias for the `get_xy_slice` function for backwards compatibility.
        """
        return self.get_xy_slice(token, channel,
                                 x_start, x_stop,
                                 y_start, y_stop,
                                 z_index,
                                 resolution)

    @_check_token
    def get_volume(self, token, channel,
                   x_start, x_stop,
                   y_start, y_stop,
                   z_start, z_stop,
                   resolution=1,
                   block_size=DEFAULT_BLOCK_SIZE,
                   neariso=False):
        """
        Get a RAMONVolume volumetric cutout from the neurodata server.

        Arguments:
            token (str): Token to identify data to download
            channel (str): Channel
            resolution (int): Resolution level
            Q_start (int): The lower bound of dimension 'Q'
            Q_stop (int): The upper bound of dimension 'Q'
            block_size (int[3]): Block size of this dataset
            neariso (bool : False): Passes the 'neariso' param to the cutout.
                If you don't know what this means, ignore it!

        Returns:
            ndio.ramon.RAMONVolume: Downloaded data.
        """
        size = (x_stop-x_start)*(y_stop-y_start)*(z_stop-z_start)
        volume = ramon.RAMONVolume()
        volume.xyz_offset = [x_start, y_start, z_start]
        volume.resolution = resolution

        volume.cutout = self.get_cutout(token, channel, x_start,
                                        x_stop, y_start, y_stop,
                                        z_start, z_stop,
                                        resolution=resolution,
                                        block_size=block_size,
                                        neariso=neariso)
        return volume

    @_check_token
    def get_cutout(self, token, channel,
                   x_start, x_stop,
                   y_start, y_stop,
                   z_start, z_stop,
                   resolution=1,
                   block_size=DEFAULT_BLOCK_SIZE,
                   neariso=False):
        """
        Get volumetric cutout data from the neurodata server.

        Arguments:
            token (str): Token to identify data to download
            channel (str): Channel
            resolution (int): Resolution level
            Q_start (int): The lower bound of dimension 'Q'
            Q_stop (int): The upper bound of dimension 'Q'
            block_size (int[3]): Block size of this dataset. If not provided,
                ndio uses the metadata of this tokenchannel to set. If you find
                that your downloads are timing out or otherwise failing, it may
                be wise to start off by making this smaller.
            neariso (bool : False): Passes the 'neariso' param to the cutout.
                If you don't know what this means, ignore it!

        Returns:
            numpy.ndarray: Downloaded data.
        """
        if block_size is None:
            # look up block size from metadata
            block_size = self.get_block_size(token, resolution)

        origin = self.get_image_offset(token, resolution)

        # If z_stop - z_start is < 16, backend still pulls minimum 16 slices
        if (z_stop - z_start) < 16:
            z_slices = 16
        else:
            z_slices = z_stop - z_start

        # Calculate size of the data to be downloaded.
        size = (x_stop - x_start) * (y_stop - y_start) * z_slices * 4

        # Switch which download function to use based on which libraries are
        # available in this version of python.
        if six.PY2:
            dl_func = self._get_cutout_blosc_no_chunking
        elif six.PY3:
            dl_func = self._get_cutout_no_chunking
        else:
            raise ValueError("Invalid Python version.")

        if size < self._chunk_threshold:
            vol = dl_func(token, channel, resolution,
                          x_start, x_stop,
                          y_start, y_stop,
                          z_start, z_stop, neariso=neariso)
            vol = numpy.rollaxis(vol, 1)
            vol = numpy.rollaxis(vol, 2)
            return vol
        else:
            from ndio.utils.parallel import block_compute
            blocks = block_compute(x_start, x_stop,
                                   y_start, y_stop,
                                   z_start, z_stop,
                                   origin, block_size)

            vol = numpy.zeros(((z_stop - z_start),
                              (y_stop - y_start),
                              (x_stop - x_start)))
            for b in blocks:

                data = dl_func(token, channel, resolution,
                               b[0][0], b[0][1],
                               b[1][0], b[1][1],
                               b[2][0], b[2][1], neariso=neariso)

                if b == blocks[0]:  # first block
                    vol = numpy.zeros(((z_stop - z_start),
                                       (y_stop - y_start),
                                       (x_stop - x_start)), dtype=data.dtype)

                vol[b[2][0]-z_start: b[2][1]-z_start,
                    b[1][0]-y_start: b[1][1]-y_start,
                    b[0][0]-x_start: b[0][1]-x_start] = data

            vol = numpy.rollaxis(vol, 1)
            vol = numpy.rollaxis(vol, 2)
            return vol

    def _get_cutout_no_chunking(self, token, channel, resolution,
                                x_start, x_stop, y_start, y_stop,
                                z_start, z_stop, neariso=False):
        url = self.url() + "{}/{}/hdf5/{}/{},{}/{},{}/{},{}/".format(
           token, channel, resolution,
           x_start, x_stop,
           y_start, y_stop,
           z_start, z_stop
        )

        if neariso:
            url += "neariso/"

        req = requests.get(url)
        if req.status_code is not 200:
            raise IOError("Bad server response for {}: {}: {}".format(
                          url,
                          req.status_code,
                          req.text))

        with tempfile.NamedTemporaryFile() as tmpfile:
            tmpfile.write(req.content)
            tmpfile.seek(0)
            h5file = h5py.File(tmpfile.name, "r")
            return h5file.get(channel).get('CUTOUT')[:]
        raise IOError("Failed to make tempfile.")

    def _get_cutout_blosc_no_chunking(self, token, channel, resolution,
                                      x_start, x_stop, y_start, y_stop,
                                      z_start, z_stop, neariso=False):

        url = self.url() + "{}/{}/blosc/{}/{},{}/{},{}/{},{}/".format(
           token, channel, resolution,
           x_start, x_stop,
           y_start, y_stop,
           z_start, z_stop
        )

        if neariso:
            url += "neariso/"

        req = requests.get(url)
        if req.status_code is not 200:
            raise IOError("Bad server response for {}: {}: {}".format(
                          url,
                          req.status_code,
                          req.text))

        # This will need modification for >3D blocks
        return blosc.unpack_array(req.content)[0]

        raise IOError("Failed to retrieve blosc cutout.")

    # SECTION:
    # Data Upload

    @_check_token
    def post_cutout(self, token, channel,
                    x_start,
                    y_start,
                    z_start,
                    data,
                    resolution=0):
        """
        Post a cutout to the server.

        Arguments:
            token (str)
            channel (str)
            x_start (int)
            y_start (int)
            z_start (int)
            data (numpy.ndarray): A numpy array of data. Pass in (x, y, z)
            resolution (int : 0): Resolution at which to insert the data

        Returns:
            bool: True on success

        Raises:
            RemoteDataUploadError: if there's an issue during upload.
        """
        datatype = self.get_proj_info(token)['channels'][channel]['datatype']
        if data.dtype.name != datatype:
            data = data.astype(datatype)

        data = numpy.rollaxis(data, 1)
        data = numpy.rollaxis(data, 2)

        if six.PY3 or data.nbytes > 1.5e9:
            ul_func = self._post_cutout_no_chunking_npz
        else:
            ul_func = self._post_cutout_no_chunking_blosc

        if data.size < self._chunk_threshold:
            return ul_func(token, channel, x_start,
                           y_start, z_start, data,
                           resolution)

        return self._post_cutout_with_chunking(token, channel,
                                               x_start, y_start, z_start, data,
                                               resolution, ul_func)

    def _post_cutout_with_chunking(self, token, channel, x_start,
                                   y_start, z_start, data,
                                   resolution, ul_func):
        # must chunk first
        from ndio.utils.parallel import block_compute
        blocks = block_compute(x_start, x_start + data.shape[2],
                               y_start, y_start + data.shape[1],
                               z_start, z_start + data.shape[0])
        for b in blocks:
            # data coordinate relative to the size of the arra
            subvol = data[b[2][0]-z_start: b[2][1]-z_start,
                          b[1][0]-y_start: b[1][1]-y_start,
                          b[0][0]-x_start: b[0][1]-x_start]
            # upload the chunk:
            # upload coordinate relative to x_start, y_start, z_start
            ul_func(token, channel, b[0][0],
                    b[1][0], b[2][0], subvol,
                    resolution)
        return True

    def _post_cutout_no_chunking_npz(self, token, channel,
                                     x_start, y_start, z_start,
                                     data, resolution):

        data = numpy.expand_dims(data, axis=0)
        tempfile = BytesIO()
        numpy.save(tempfile, data)
        compressed = zlib.compress(tempfile.getvalue())

        url = self.url("{}/{}/npz/{}/{},{}/{},{}/{},{}/".format(
            token, channel,
            resolution,
            x_start, x_start + data.shape[3],
            y_start, y_start + data.shape[2],
            z_start, z_start + data.shape[1]
        ))

        req = requests.post(url, data=compressed, headers={
            'Content-Type': 'application/octet-stream'
        })

        if req.status_code is not 200:
            raise RemoteDataUploadError(req.text)
        else:
            return True

    def _post_cutout_no_chunking_blosc(self, token, channel,
                                       x_start, y_start, z_start,
                                       data, resolution):
        """
        Accepts data in zyx. !!!
        """
        data = numpy.expand_dims(data, axis=0)
        blosc_data = blosc.pack_array(data)

        url = self.url("{}/{}/blosc/{}/{},{}/{},{}/{},{}/".format(
            token, channel,
            resolution,
            x_start, x_start + data.shape[3],
            y_start, y_start + data.shape[2],
            z_start, z_start + data.shape[1]
        ))
        req = requests.post(url, data=blosc_data, headers={
            'Content-Type': 'application/octet-stream'
        })

        if req.status_code is not 200:
            raise RemoteDataUploadError(req.text)
        else:
            return True

    # SECTION:
    # RAMON Download

    @_check_token
    def get_ramon_bounding_box(self, token, channel, r_id, resolution=0):
        """
        Get the bounding box for a RAMON object (specified by ID).

        Arguments:
            token (str): Project to use
            channel (str): Channel to use
            r_id (int): Which ID to get a bounding box
            resolution (int : 0): The resolution at which to download

        Returns:
            (x_start, x_stop, y_start, y_stop, z_start, z_stop): ints
        """
        url = self.url('{}/{}/{}/boundingbox/{}/'.format(token, channel,
                                                         r_id, resolution))

        r_id = str(r_id)
        res = requests.get(url)

        if res.status_code != 200:
            rt = self.get_ramon_metadata(token, channel, r_id)[r_id]['type']
            if rt in ['neuron']:
                raise ValueError("ID {} is of type '{}'".format(r_id, rt))
            raise RemoteDataNotFoundError("No such ID {}".format(r_id))

        with tempfile.NamedTemporaryFile() as tmpfile:
            tmpfile.write(res.content)
            tmpfile.seek(0)
            h5file = h5py.File(tmpfile.name, "r")
            origin = h5file["{}/XYZOFFSET".format(r_id)][()]
            size = h5file["{}/XYZDIMENSION".format(r_id)][()]
            return (origin[0], origin[0] + size[0],
                    origin[1], origin[1] + size[1],
                    origin[2], origin[2] + size[2])

    @_check_token
    def get_ramon_ids(self, token, channel, ramon_type=None):
        """
        Return a list of all IDs available for download from this token and
        channel.

        Arguments:
            token (str): Project to use
            channel (str): Channel to use
            ramon_type (int : None): Optional. If set, filters IDs and only
                returns those of RAMON objects of the requested type.

        Returns:
            int[]: A list of the ids of the returned RAMON objects

        Raises:
            RemoteDataNotFoundError: If the channel or token is not found
        """
        url = self.url("{}/{}/query/".format(token, channel))
        if ramon_type is not None:
            # User is requesting a specific ramon_type.
            if type(ramon_type) is not int:
                ramon_type = ramon.AnnotationType.get_int(ramon_type)
            url += "type/{}/".format(str(ramon_type))

        req = requests.get(url)

        if req.status_code is not 200:
            raise RemoteDataNotFoundError('No query results for token {}.'
                                          .format(token))
        else:
            with tempfile.NamedTemporaryFile() as tmpfile:
                tmpfile.write(req.content)
                tmpfile.seek(0)
                h5file = h5py.File(tmpfile.name, "r")
                if 'ANNOIDS' not in h5file:
                    return []
                return [i for i in h5file['ANNOIDS']]
            raise IOError("Could not successfully mock HDF5 file for parsing.")

    @_check_token
    def get_ramon(self, token, channel, ids, resolution=0,
                  include_cutout=False, sieve=None, batch_size=100):
        """
        Download a RAMON object by ID.

        Arguments:
            token (str): Project to use
            channel (str): The channel to use
            ids (int, str, int[], str[]): The IDs of a RAMON object to gather.
                Can be int (3), string ("3"), int[] ([3, 4, 5]), or string
                (["3", "4", "5"]).
            resolution (int : None): Resolution. Defaults to the most granular
                resolution (0 for now)
            include_cutout (bool : False):  If True, r.cutout is populated
            sieve (function : None): A function that accepts a single ramon
                and returns True or False depending on whether you want that
                ramon object to be included in your response or not.
                For example,
                ```
                def is_even_id(ramon):
                    return ramon.id % 2 == 0
                ```
                You can then pass this to get_ramon like this:
                ```
                ndio.remote.neurodata.get_ramon( . . . , sieve=is_even_id)
                ```
            batch_size (int : 100): The amount of RAMON objects to download at
                a time. If this is greater than 100, we anticipate things going
                very poorly for you. So if you set it <100, ndio will use it.
                If >=100, set it to 100.

        Returns:
            ndio.ramon.RAMON[]: A list of returned RAMON objects.

        Raises:
            RemoteDataNotFoundError: If the requested ids cannot be found.
        """
        b_size = min(100, batch_size)

        _return_first_only = False
        if type(ids) is not list:
            _return_first_only = True
            ids = [ids]
        ids = [str(i) for i in ids]

        rs = []
        id_batches = [ids[i:i+b_size] for i in range(0, len(ids), b_size)]
        for batch in id_batches:
            rs.extend(self._get_ramon_batch(token, channel, batch, resolution))

        rs = self._filter_ramon(rs, sieve)

                # if 'cutout' not in dir(ramon):
                #     return ramon
        if include_cutout:
            rs = [self._add_ramon_cutout(token, channel, r, resolution)
                  for r in rs]

        if _return_first_only:
            return rs[0]

        return sorted(rs, key=lambda x: ids.index(x.id))

    def _filter_ramon(self, rs, sieve):
        if sieve is not None:
            return [r for r in rs if sieve(r)]
        return rs

    def _add_ramon_cutout(self, token, channel, ramon, resolution):
        origin = ramon.xyz_offset
        # Get the bounding box (cube-aligned)
        bbox = self.get_ramon_bounding_box(token, channel,
                                           ramon.id, resolution=resolution)
        # Get the cutout (cube-aligned)
        cutout = self.get_cutout(token, channel,
                                 *bbox, resolution=resolution)
        cutout[cutout != int(ramon.id)] = 0

        # Compute upper offset and crop
        bounds = numpy.argwhere(cutout)
        mins = [min([i[dim] for i in bounds]) for dim in range(3)]
        maxs = [max([i[dim] for i in bounds]) for dim in range(3)]

        ramon.cutout = cutout[
            mins[0]:maxs[0],
            mins[1]:maxs[1],
            mins[2]:maxs[2]
        ]

        return ramon

    def _get_ramon_batch(self, token, channel, ids, resolution):
        ids = [str(i) for i in ids]
        url = self.url("{}/{}/{}/json/".format(token, channel, ",".join(ids)))
        req = requests.get(url)

        if req.status_code is not 200:
            raise RemoteDataNotFoundError('No data for id {}.'.format(ids))
        else:
            return ramon.from_json(req.json())

    @_check_token
    def get_ramon_metadata(self, token, channel, anno_id):
        """
        Download a RAMON object by ID. `anno_id` can be a string `"123"`, an
        int `123`, an array of ints `[123, 234, 345]`, an array of strings
        `["123", "234", "345"]`, or a comma-separated string list
        `"123,234,345"`.

        Arguments:
            token (str): Project to use
            channel (str): The channel to use
            anno_id: An int, a str, or a list of ids to gather

        Returns:
            JSON. If you pass a single id in str or int, returns a single datum
            If you pass a list of int or str or a comma-separated string, will
            return a dict with keys from the list and the values are the JSON
            returned from the server.

        Raises:
            RemoteDataNotFoundError: If the data cannot be found on the Remote
        """
        if type(anno_id) in [int, numpy.uint32]:
            # there's just one ID to download
            return self._get_single_ramon_metadata(token, channel,
                                                   str(anno_id))
        elif type(anno_id) is str:
            # either "id" or "id,id,id":
            if (len(anno_id.split(',')) > 1):
                results = {}
                for i in anno_id.split(','):
                    results[i] = self._get_single_ramon_metadata(
                        token, channel, anno_id.strip()
                    )
                return results
            else:
                # "id"
                return self._get_single_ramon_metadata(token, channel,
                                                       anno_id.strip())
        elif type(anno_id) is list:
            # [id, id] or ['id', 'id']
            results = []
            for i in anno_id:
                results.append(self._get_single_ramon_metadata(token, channel,
                                                               str(i)))
            return results

    def _get_single_ramon_metadata(self, token, channel, anno_id):
        req = requests.get(self.url() +
                           "{}/{}/{}/json/".format(token, channel, anno_id))
        if req.status_code is not 200:
            raise RemoteDataNotFoundError('No data for id {}.'.format(anno_id))
        return req.json()

    @_check_token
    def delete_ramon(self, token, channel, anno):
        """
        Deletes an annotation from the server. Probably you should be careful
        with this function, it seems dangerous.

        Arguments:
            token (str): The token to inspect
            channel (str): The channel to inspect
            anno (int OR list(int) OR RAMON): The annotation to delete. If a
                RAMON object is supplied, the remote annotation will be deleted
                by an ID lookup. If an int is supplied, the annotation will be
                deleted for that ID. If a list of ints are provided, they will
                all be deleted.

        Returns:
            bool: Success
        """
        if type(anno) is int:
            a = anno
        if type(anno) is str:
            a = int(anno)
        if type(anno) is list:
            a = ",".join(anno)
        else:
            a = anno.id

        req = requests.delete(self.url("{}/{}/{}/".format(token, channel, a)))
        if req.status_code is not 200:
            raise RemoteDataNotFoundError("Could not delete id {}: {}"
                                          .format(a, req.text))
        else:
            return True

    @_check_token
    def post_ramon(self, token, channel, r, batch_size=100):
        """
        Posts a RAMON object to the Remote.

        Arguments:
            token (str): Project to use
            channel (str): The channel to use
            r (RAMON or RAMON[]): The annotation(s) to upload
            batch_size (int : 100): The number of RAMONs to post simultaneously
                at maximum in one file. If len(r) > batch_size, the batch will
                be split and uploaded automatically. Must be less than 100.

        Returns:
            bool: Success = True

        Throws:
            RemoteDataUploadError: if something goes wrong
        """
        # Max out batch-size at 100.
        b_size = min(100, batch_size)

        # Coerce incoming IDs to a list.
        if type(r) is not list:
            r = [r]

        # If there are too many to fit in one batch, split here and call this
        # function recursively.
        if len(r) > batch_size:
            batches = [r[i:i+b_size] for i in range(0, len(r), b_size)]
            for batch in batches:
                self.post_ramon(token, channel, batch, b_size)
            return

        with tempfile.NamedTemporaryFile(delete=False) as tmpfile:
            for i in r:
                tmpfile = ramon.to_hdf5(i, tmpfile)

            url = self.url("{}/{}/overwrite/".format(token, channel))
            req = urllib2.Request(url, tmpfile.read())
            res = urllib2.urlopen(req)

            if res.code != 200:
                raise RemoteDataUploadError('[{}] Could not upload {}'
                                            .format(res.code, str(r)))

            rets = res.read()
            if six.PY3:
                rets = rets.decode()
            return_ids = [int(rid) for rid in rets.split(',')]

            # Now post the cutout separately:
            for ri in r:
                if 'cutout' in dir(ri) and ri.cutout is not None:
                    orig = ri.xyz_offset
                    self.post_cutout(token, channel,
                                     orig[0], orig[1], orig[2],
                                     ri.cutout, resolution=r.resolution)
            return return_ids
        return True

    # SECTION:
    # ID Manipulation

    @_check_token
    def reserve_ids(self, token, channel, quantity):
        """
        Requests a list of next-available-IDs from the server.

        Arguments:
            quantity (int): The number of IDs to reserve

        Returns:
            int[quantity]: List of IDs you've been granted
        """
        quantity = str(quantity)
        url = self.url("{}/{}/reserve/{}/".format(token, channel, quantity))
        req = requests.get(url)
        if req.status_code is not 200:
            raise RemoteDataNotFoundError('Invalid req: ' + req.status_code)
        out = req.json()
        return [out[0] + i for i in range(out[1])]

    @_check_token
    def merge_ids(self, token, channel, ids, delete=False):
        """
        Call the restful endpoint to merge two RAMON objects into one.

        Arguments:
            token (str): The token to inspect
            channel (str): The channel to inspect
            ids (int[]): the list of the IDs to merge
            delete (bool : False): Whether to delete after merging.

        Returns:
            json: The ID as returned by ndstore
        """
        req = requests.get(self.url() + "/merge/{}/"
                           .format(','.join([str(i) for i in ids])))
        if req.status_code is not 200:
            raise RemoteDataUploadError('Could not merge ids {}'.format(
                                        ','.join([str(i) for i in ids])))
        if delete:
            self.delete_ramon(token, channel, ids[1:])
        return True

    # SECTION:
    # Channels

    def _check_channel(self, channel):
        for c in channel:
            if not c.isalnum():
                raise ValueError(
                    "Channel name cannot contain character {}.".format(c)
                )
        return True

    @_check_token
    def create_channel(self, token, name, channel_type, dtype, readonly):
        """
        Create a new channel on the Remote, using channel_data.

        Arguments:
            token (str): The token the new channel should be added to
            name (str): The name of the channel to add
            channel_type (str): Type of the channel (e.g. `neurodata.IMAGE`)
            dtype (str): The datatype of the channel's data (e.g. `uint8`)
            readonly (bool): Can others write to this channel?

        Returns:
            bool: `True` if successful, `False` otherwise.

        Raises:
            ValueError: If your args were bad :(
            RemoteDataUploadError: If the channel data is valid but upload
                fails for some other reason.
        """
        self._check_channel(name)

        if channel_type not in ['image', 'annotation']:
            raise ValueError('Channel type must be ' +
                             'neurodata.IMAGE or neurodata.ANNOTATION.')

        if readonly * 1 not in [0, 1]:
            raise ValueError("readonly must be 0 (False) or 1 (True).")

        # Good job! You supplied very nice arguments.
        req = requests.post(self.url("{}/createChannel/".format(token)), json={
            "channels": {
                name: {
                    "channel_name": name,
                    "channel_type": channel_type,
                    "datatype": dtype,
                    "readonly": readonly * 1
                }
            }
        })

        if req.status_code is not 200:
            raise RemoteDataUploadError('Could not upload {}'.format(req.text))
        else:
            return True

    @_check_token
    def delete_channel(self, token, name):
        """
        Delete an existing channel on the Remote. Be careful!

        Arguments:
            token (str): The token the new channel should be deleted from
            name (str): The name of the channel to delete

        Returns:
            bool: True if successful, False otherwise.

        Raises:
            RemoteDataUploadError: If the upload fails for some reason.
        """
        req = requests.post(self.url("{}/deleteChannel/".format(token)), json={
            "channels": [name]
        })

        if req.status_code is not 200:
            raise RemoteDataUploadError('Could not delete {}'.format(req.text))
        if req.content == "SUCCESS":
            return True
        else:
            return False

    # Propagation

    @_check_token
    def propagate(self, token, channel):
        """
        Kick off the propagate function on the remote server.

        Arguments:
            token (str): The token to propagate
            channel (str): The channel to propagate

        Returns:
            boolean: Success
        """
        if self.get_propagate_status(token, channel) is not 0:
            return
        url = self.url('{}/{}/setPropagate/1/'.format(token, channel))
        req = requests.get(url)
        if req.status_code is not 200:
            raise RemoteDataUploadError('Propagate fail: {}'.format(req.text))
        return True

    @_check_token
    def get_propagate_status(self, token, channel):
        """
        Get the propagate status for a token/channel pair.

        Arguments:
            token (str): The token to check
            channel (str): The channel to check

        Returns:
            str: The status code
        """
        url = self.url('{}/{}/getPropagate/'.format(token, channel))
        req = requests.get(url)
        if req.status_code is not 200:
            raise ValueError('Bad pair: {}/{}'.format(token, channel))
        return req.text
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#ndio.remote.neurodata.neurodata">neurodata</a></li>
          <li>ndio.remote.Remote.Remote</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="ndio.remote.neurodata.neurodata.ANNO" class="name">var <span class="ident">ANNO</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ndio.remote.neurodata.neurodata.ANNOTATION" class="name">var <span class="ident">ANNOTATION</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ndio.remote.neurodata.neurodata.IMAGE" class="name">var <span class="ident">IMAGE</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ndio.remote.neurodata.neurodata.IMG" class="name">var <span class="ident">IMG</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, hostname=&#39;openconnecto.me&#39;, protocol=&#39;http&#39;, meta_root=&#39;http://lims.neurodata.io/&#39;, meta_protocol=&#39;http&#39;, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Initializer for the neurodata remote class.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>hostname (str: "openconnecto.me")</b>: The hostname to connect to<br />
&emsp;&emsp;&emsp;&emsp;<b>protocol (str: "http")</b>: The protocol (http or https) to use<br />
&emsp;&emsp;&emsp;&emsp;<b>meta_root (str: "http://lims.neurodata.io/")</b>: The metadata server<br />
&emsp;&emsp;&emsp;&emsp;<b>meta_protocol (str: "http")</b>: The protocol to use for the md server<br />
&emsp;&emsp;&emsp;&emsp;<b>check_tokens (boolean: False)</b>: Whether functions that take <code>token</code><br />
        as an argument should check for the existance of that token and<br />
        fail immediately if it is not found. This is a good idea for<br />
        functions that take more time to complete, and might not fail<br />
        until the very end otherwise.<br />
&emsp;&emsp;&emsp;&emsp;<b>chunk_threshold (int: 1e9 / 4)</b>: The maximum size of a numpy array<br />
        that will be uploaded in one HTTP request. If you find that<br />
        your data requests are commonly timing out, try reducing this.<br />
        Default is 1e9 / 4, or a 0.25GiB.<br />
&emsp;&emsp;&emsp;&emsp;<b>suffix (str: "ocp")</b>: The URL suffix to specify ndstore/microns. If<br />
        you aren't sure what to do with this, don't specify one.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.__init__', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.__init__" class="source">
    <pre><code>def __init__(self,
             hostname=DEFAULT_HOSTNAME,
             protocol=DEFAULT_PROTOCOL,
             meta_root="http://lims.neurodata.io/",
             meta_protocol=DEFAULT_PROTOCOL, **kwargs):
    """
    Initializer for the neurodata remote class.
    Arguments:
        hostname (str: "openconnecto.me"): The hostname to connect to
        protocol (str: "http"): The protocol (http or https) to use
        meta_root (str: "http://lims.neurodata.io/"): The metadata server
        meta_protocol (str: "http"): The protocol to use for the md server
        check_tokens (boolean: False): Whether functions that take `token`
            as an argument should check for the existance of that token and
            fail immediately if it is not found. This is a good idea for
            functions that take more time to complete, and might not fail
            until the very end otherwise.
        chunk_threshold (int: 1e9 / 4): The maximum size of a numpy array
            that will be uploaded in one HTTP request. If you find that
            your data requests are commonly timing out, try reducing this.
            Default is 1e9 / 4, or a 0.25GiB.
        suffix (str: "ocp"): The URL suffix to specify ndstore/microns. If
            you aren't sure what to do with this, don't specify one.
    """
    self._check_tokens = kwargs.get('check_tokens', False)
    self._chunk_threshold = kwargs.get('chunk_threshold', 1E9 / 4)
    self._ext = kwargs.get('suffix', DEFAULT_SUFFIX)
    self._known_tokens = []
    # Prepare meta url
    self.meta_root = meta_root
    if not self.meta_root.endswith('/'):
        self.meta_root = self.meta_root + "/"
    if self.meta_root.startswith('http'):
        self.meta_root = self.meta_root[self.meta_root.index('://')+3:]
    self.meta_protocol = meta_protocol
    super(neurodata, self).__init__(hostname, protocol)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.add_subvolume">
    <p>def <span class="ident">add_subvolume</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds a new subvolume to a token/channel.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: The token to write to in LIMS<br />
&emsp;&emsp;&emsp;&emsp;<b>channel (str)</b>: Channel to add in the subvolume. Can be <code>None</code><br />
&emsp;&emsp;&emsp;&emsp;<b>x_start (int)</b>: Start in x dimension<br />
&emsp;&emsp;&emsp;&emsp;<b>x_stop (int)</b>: Stop in x dimension<br />
&emsp;&emsp;&emsp;&emsp;<b>y_start (int)</b>: Start in y dimension<br />
&emsp;&emsp;&emsp;&emsp;<b>y_stop (int)</b>: Stop in y dimension<br />
&emsp;&emsp;&emsp;&emsp;<b>z_start (int)</b>: Start in z dimension<br />
&emsp;&emsp;&emsp;&emsp;<b>z_stop (int)</b>: Stop in z dimension<br />
&emsp;&emsp;&emsp;&emsp;<b>resolution (int)</b>: The resolution at which this subvolume is seen<br />
&emsp;&emsp;&emsp;&emsp;<b>title (str)</b>: The title to set for the subvolume<br />
&emsp;&emsp;&emsp;&emsp;<b>notes (str)</b>: Optional extra thoughts on the subvolume</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>boolean</b>: success</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.add_subvolume', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.add_subvolume" class="source">
    <pre><code>@_check_token
def add_subvolume(self, token, channel, secret,
                  x_start, x_stop,
                  y_start, y_stop,
                  z_start, z_stop,
                  resolution, title, notes):
    """
    Adds a new subvolume to a token/channel.
    Arguments:
        token (str): The token to write to in LIMS
        channel (str): Channel to add in the subvolume. Can be `None`
        x_start (int): Start in x dimension
        x_stop (int): Stop in x dimension
        y_start (int): Start in y dimension
        y_stop (int): Stop in y dimension
        z_start (int): Start in z dimension
        z_stop (int): Stop in z dimension
        resolution (int): The resolution at which this subvolume is seen
        title (str): The title to set for the subvolume
        notes (str): Optional extra thoughts on the subvolume
    Returns:
        boolean: success
    """
    md = self.get_metadata(token)['metadata']
    if 'subvolumes' in md:
        subvols = md['subvolumes']
    else:
        subvols = []
    subvols.append({
        'token': token,
        'channel': channel,
        'x_start': x_start,
        'x_stop': x_stop,
        'y_start': y_start,
        'y_stop': y_stop,
        'z_start': z_start,
        'z_stop': z_stop,
        'resolution': resolution,
        'title': title,
        'notes': notes
    })
    return self.set_metadata(token, {
        'secret': secret,
        'subvolumes': subvols
    })
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.create_channel">
    <p>def <span class="ident">create_channel</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a new channel on the Remote, using channel_data.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: The token the new channel should be added to<br />
&emsp;&emsp;&emsp;&emsp;<b>name (str)</b>: The name of the channel to add<br />
&emsp;&emsp;&emsp;&emsp;<b>channel_type (str)</b>: Type of the channel (e.g. <code>neurodata.IMAGE</code>)<br />
&emsp;&emsp;&emsp;&emsp;<b>dtype (str)</b>: The datatype of the channel's data (e.g. <code>uint8</code>)<br />
&emsp;&emsp;&emsp;&emsp;<b>readonly (bool)</b>: Can others write to this channel?</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>bool</b>: <code>True</code> if successful, <code>False</code> otherwise.</p>
<h2 style='font-size:125% !important'>Raises</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>ValueError</b>: If your args were bad :(<br />
&emsp;&emsp;&emsp;&emsp;<b>RemoteDataUploadError</b>: If the channel data is valid but upload<br />
        fails for some other reason.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.create_channel', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.create_channel" class="source">
    <pre><code>@_check_token
def create_channel(self, token, name, channel_type, dtype, readonly):
    """
    Create a new channel on the Remote, using channel_data.
    Arguments:
        token (str): The token the new channel should be added to
        name (str): The name of the channel to add
        channel_type (str): Type of the channel (e.g. `neurodata.IMAGE`)
        dtype (str): The datatype of the channel's data (e.g. `uint8`)
        readonly (bool): Can others write to this channel?
    Returns:
        bool: `True` if successful, `False` otherwise.
    Raises:
        ValueError: If your args were bad :(
        RemoteDataUploadError: If the channel data is valid but upload
            fails for some other reason.
    """
    self._check_channel(name)
    if channel_type not in ['image', 'annotation']:
        raise ValueError('Channel type must be ' +
                         'neurodata.IMAGE or neurodata.ANNOTATION.')
    if readonly * 1 not in [0, 1]:
        raise ValueError("readonly must be 0 (False) or 1 (True).")
    # Good job! You supplied very nice arguments.
    req = requests.post(self.url("{}/createChannel/".format(token)), json={
        "channels": {
            name: {
                "channel_name": name,
                "channel_type": channel_type,
                "datatype": dtype,
                "readonly": readonly * 1
            }
        }
    })
    if req.status_code is not 200:
        raise RemoteDataUploadError('Could not upload {}'.format(req.text))
    else:
        return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.delete_channel">
    <p>def <span class="ident">delete_channel</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Delete an existing channel on the Remote. Be careful!</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: The token the new channel should be deleted from<br />
&emsp;&emsp;&emsp;&emsp;<b>name (str)</b>: The name of the channel to delete</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>bool</b>: True if successful, False otherwise.</p>
<h2 style='font-size:125% !important'>Raises</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>RemoteDataUploadError</b>: If the upload fails for some reason.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.delete_channel', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.delete_channel" class="source">
    <pre><code>@_check_token
def delete_channel(self, token, name):
    """
    Delete an existing channel on the Remote. Be careful!
    Arguments:
        token (str): The token the new channel should be deleted from
        name (str): The name of the channel to delete
    Returns:
        bool: True if successful, False otherwise.
    Raises:
        RemoteDataUploadError: If the upload fails for some reason.
    """
    req = requests.post(self.url("{}/deleteChannel/".format(token)), json={
        "channels": [name]
    })
    if req.status_code is not 200:
        raise RemoteDataUploadError('Could not delete {}'.format(req.text))
    if req.content == "SUCCESS":
        return True
    else:
        return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.delete_ramon">
    <p>def <span class="ident">delete_ramon</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Deletes an annotation from the server. Probably you should be careful<br />
with this function, it seems dangerous.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: The token to inspect<br />
&emsp;&emsp;&emsp;&emsp;<b>channel (str)</b>: The channel to inspect<br />
&emsp;&emsp;&emsp;&emsp;<b>anno (int OR list(int) OR RAMON)</b>: The annotation to delete. If a<br />
        RAMON object is supplied, the remote annotation will be deleted<br />
        by an ID lookup. If an int is supplied, the annotation will be<br />
        deleted for that ID. If a list of ints are provided, they will<br />
        all be deleted.</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>bool</b>: Success</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.delete_ramon', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.delete_ramon" class="source">
    <pre><code>@_check_token
def delete_ramon(self, token, channel, anno):
    """
    Deletes an annotation from the server. Probably you should be careful
    with this function, it seems dangerous.
    Arguments:
        token (str): The token to inspect
        channel (str): The channel to inspect
        anno (int OR list(int) OR RAMON): The annotation to delete. If a
            RAMON object is supplied, the remote annotation will be deleted
            by an ID lookup. If an int is supplied, the annotation will be
            deleted for that ID. If a list of ints are provided, they will
            all be deleted.
    Returns:
        bool: Success
    """
    if type(anno) is int:
        a = anno
    if type(anno) is str:
        a = int(anno)
    if type(anno) is list:
        a = ",".join(anno)
    else:
        a = anno.id
    req = requests.delete(self.url("{}/{}/{}/".format(token, channel, a)))
    if req.status_code is not 200:
        raise RemoteDataNotFoundError("Could not delete id {}: {}"
                                      .format(a, req.text))
    else:
        return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_block_size">
    <p>def <span class="ident">get_block_size</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Gets the block-size for a given token at a given resolution.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: The token to inspect<br />
&emsp;&emsp;&emsp;&emsp;<b>resolution (int : None)</b>: The resolution at which to inspect data.<br />
        If none is specified, uses the minimum available.</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>int[3]</b>: The xyz blocksize.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_block_size', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_block_size" class="source">
    <pre><code>@_check_token
def get_block_size(self, token, resolution=None):
    """
    Gets the block-size for a given token at a given resolution.
    Arguments:
        token (str): The token to inspect
        resolution (int : None): The resolution at which to inspect data.
            If none is specified, uses the minimum available.
    Returns:
        int[3]: The xyz blocksize.
    """
    cdims = self.get_metadata(token)['dataset']['cube_dimension']
    if resolution is None:
        resolution = min(cdims.keys())
    return cdims[str(resolution)]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_channels">
    <p>def <span class="ident">get_channels</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Wraps get_proj_info to return a dictionary of just the channels of<br />
a given project.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: Token to return channels for</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>JSON</b>: dictionary of channels.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_channels', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_channels" class="source">
    <pre><code>@_check_token
def get_channels(self, token):
    """
    Wraps get_proj_info to return a dictionary of just the channels of
    a given project.
    Arguments:
        token (str): Token to return channels for
    Returns:
        JSON: dictionary of channels.
    """
    return self.get_proj_info(token)['channels']
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_cutout">
    <p>def <span class="ident">get_cutout</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Get volumetric cutout data from the neurodata server.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: Token to identify data to download<br />
&emsp;&emsp;&emsp;&emsp;<b>channel (str)</b>: Channel<br />
&emsp;&emsp;&emsp;&emsp;<b>resolution (int)</b>: Resolution level<br />
&emsp;&emsp;&emsp;&emsp;<b>Q_start (int)</b>: The lower bound of dimension 'Q'<br />
&emsp;&emsp;&emsp;&emsp;<b>Q_stop (int)</b>: The upper bound of dimension 'Q'<br />
&emsp;&emsp;&emsp;&emsp;<b>block_size (int[3])</b>: Block size of this dataset. If not provided,<br />
        ndio uses the metadata of this tokenchannel to set. If you find<br />
        that your downloads are timing out or otherwise failing, it may<br />
        be wise to start off by making this smaller.<br />
&emsp;&emsp;&emsp;&emsp;<b>neariso (bool : False)</b>: Passes the 'neariso' param to the cutout.<br />
        If you don't know what this means, ignore it!</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>numpy.ndarray</b>: Downloaded data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_cutout', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_cutout" class="source">
    <pre><code>@_check_token
def get_cutout(self, token, channel,
               x_start, x_stop,
               y_start, y_stop,
               z_start, z_stop,
               resolution=1,
               block_size=DEFAULT_BLOCK_SIZE,
               neariso=False):
    """
    Get volumetric cutout data from the neurodata server.
    Arguments:
        token (str): Token to identify data to download
        channel (str): Channel
        resolution (int): Resolution level
        Q_start (int): The lower bound of dimension 'Q'
        Q_stop (int): The upper bound of dimension 'Q'
        block_size (int[3]): Block size of this dataset. If not provided,
            ndio uses the metadata of this tokenchannel to set. If you find
            that your downloads are timing out or otherwise failing, it may
            be wise to start off by making this smaller.
        neariso (bool : False): Passes the 'neariso' param to the cutout.
            If you don't know what this means, ignore it!
    Returns:
        numpy.ndarray: Downloaded data.
    """
    if block_size is None:
        # look up block size from metadata
        block_size = self.get_block_size(token, resolution)
    origin = self.get_image_offset(token, resolution)
    # If z_stop - z_start is < 16, backend still pulls minimum 16 slices
    if (z_stop - z_start) < 16:
        z_slices = 16
    else:
        z_slices = z_stop - z_start
    # Calculate size of the data to be downloaded.
    size = (x_stop - x_start) * (y_stop - y_start) * z_slices * 4
    # Switch which download function to use based on which libraries are
    # available in this version of python.
    if six.PY2:
        dl_func = self._get_cutout_blosc_no_chunking
    elif six.PY3:
        dl_func = self._get_cutout_no_chunking
    else:
        raise ValueError("Invalid Python version.")
    if size < self._chunk_threshold:
        vol = dl_func(token, channel, resolution,
                      x_start, x_stop,
                      y_start, y_stop,
                      z_start, z_stop, neariso=neariso)
        vol = numpy.rollaxis(vol, 1)
        vol = numpy.rollaxis(vol, 2)
        return vol
    else:
        from ndio.utils.parallel import block_compute
        blocks = block_compute(x_start, x_stop,
                               y_start, y_stop,
                               z_start, z_stop,
                               origin, block_size)
        vol = numpy.zeros(((z_stop - z_start),
                          (y_stop - y_start),
                          (x_stop - x_start)))
        for b in blocks:
            data = dl_func(token, channel, resolution,
                           b[0][0], b[0][1],
                           b[1][0], b[1][1],
                           b[2][0], b[2][1], neariso=neariso)
            if b == blocks[0]:  # first block
                vol = numpy.zeros(((z_stop - z_start),
                                   (y_stop - y_start),
                                   (x_stop - x_start)), dtype=data.dtype)
            vol[b[2][0]-z_start: b[2][1]-z_start,
                b[1][0]-y_start: b[1][1]-y_start,
                b[0][0]-x_start: b[0][1]-x_start] = data
        vol = numpy.rollaxis(vol, 1)
        vol = numpy.rollaxis(vol, 2)
        return vol
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_image">
    <p>def <span class="ident">get_image</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Alias for the <code>get_xy_slice</code> function for backwards compatibility.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_image', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_image" class="source">
    <pre><code>@_check_token
def get_image(self, token, channel,
              x_start, x_stop,
              y_start, y_stop,
              z_index,
              resolution=0):
    """
    Alias for the `get_xy_slice` function for backwards compatibility.
    """
    return self.get_xy_slice(token, channel,
                             x_start, x_stop,
                             y_start, y_stop,
                             z_index,
                             resolution)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_image_offset">
    <p>def <span class="ident">get_image_offset</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Gets the image offset for a given token at a given resolution. For<br />
instance, the <code>kasthuri11</code> dataset starts at (0, 0, 1), so its 1850th<br />
slice is slice 1850, not 1849. When downloading a full dataset, the<br />
result of this function should be your x/y/z starts.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: The token to inspect<br />
&emsp;&emsp;&emsp;&emsp;<b>resolution (int : 0)</b>: The resolution at which to gather the offset</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>int[3]</b>: The origin of the dataset, as a list</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_image_offset', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_image_offset" class="source">
    <pre><code>@_check_token
def get_image_offset(self, token, resolution=0):
    """
    Gets the image offset for a given token at a given resolution. For
    instance, the `kasthuri11` dataset starts at (0, 0, 1), so its 1850th
    slice is slice 1850, not 1849. When downloading a full dataset, the
    result of this function should be your x/y/z starts.
    Arguments:
        token (str): The token to inspect
        resolution (int : 0): The resolution at which to gather the offset
    Returns:
        int[3]: The origin of the dataset, as a list
    """
    info = self.get_proj_info(token)
    res = str(resolution)
    if res not in info['dataset']['offset']:
        raise RemoteDataNotFoundError("Resolution " + res +
                                      " is not available.")
    return info['dataset']['offset'][str(resolution)]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_image_size">
    <p>def <span class="ident">get_image_size</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the size of the volume (3D). Convenient for when you want<br />
to download the entirety of a dataset.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: The token for which to find the dataset image bounds<br />
&emsp;&emsp;&emsp;&emsp;<b>resolution (int : 0)</b>: The resolution at which to get image bounds.<br />
        Defaults to 0, to get the largest area available.</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>int[3]</b>: The size of the bounds. Should == get_volume.shape</p>
<h2 style='font-size:125% !important'>Raises</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>RemoteDataNotFoundError</b>: If the token is invalid, or if the<br />
        metadata at that resolution is unavailable in projinfo.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_image_size', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_image_size" class="source">
    <pre><code>@_check_token
def get_image_size(self, token, resolution=0):
    """
    Return the size of the volume (3D). Convenient for when you want
    to download the entirety of a dataset.
    Arguments:
        token (str): The token for which to find the dataset image bounds
        resolution (int : 0): The resolution at which to get image bounds.
            Defaults to 0, to get the largest area available.
    Returns:
        int[3]: The size of the bounds. Should == get_volume.shape
    Raises:
        RemoteDataNotFoundError: If the token is invalid, or if the
            metadata at that resolution is unavailable in projinfo.
    """
    info = self.get_proj_info(token)
    res = str(resolution)
    if res not in info['dataset']['imagesize']:
        raise RemoteDataNotFoundError("Resolution " + res +
                                      " is not available.")
    return info['dataset']['imagesize'][str(resolution)]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_metadata">
    <p>def <span class="ident">get_metadata</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>An alias for get_proj_info.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_metadata', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_metadata" class="source">
    <pre><code>@_check_token
def get_metadata(self, token):
    """
    An alias for get_proj_info.
    """
    return self.get_proj_info(token)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_proj_info">
    <p>def <span class="ident">get_proj_info</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the project info for a given token.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: Token to return information for</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>JSON</b>: representation of proj_info</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_proj_info', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_proj_info" class="source">
    <pre><code>@_check_token
def get_proj_info(self, token):
    """
    Return the project info for a given token.
    Arguments:
        token (str): Token to return information for
    Returns:
        JSON: representation of proj_info
    """
    r = requests.get(self.url() + "{}/info/".format(token))
    return r.json()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_propagate_status">
    <p>def <span class="ident">get_propagate_status</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the propagate status for a token/channel pair.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: The token to check<br />
&emsp;&emsp;&emsp;&emsp;<b>channel (str)</b>: The channel to check</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>str</b>: The status code</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_propagate_status', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_propagate_status" class="source">
    <pre><code>@_check_token
def get_propagate_status(self, token, channel):
    """
    Get the propagate status for a token/channel pair.
    Arguments:
        token (str): The token to check
        channel (str): The channel to check
    Returns:
        str: The status code
    """
    url = self.url('{}/{}/getPropagate/'.format(token, channel))
    req = requests.get(url)
    if req.status_code is not 200:
        raise ValueError('Bad pair: {}/{}'.format(token, channel))
    return req.text
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_public_datasets">
    <p>def <span class="ident">get_public_datasets</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>&emsp;&emsp;&emsp;&emsp;<b>NOTE</b>: VERY SLOW!<br />
Get a list of public datasets. Different than public tokens!</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>None</b></p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>str[]</b>: list of public datasets</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_public_datasets', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_public_datasets" class="source">
    <pre><code>def get_public_datasets(self):
    """
    NOTE: VERY SLOW!
    Get a list of public datasets. Different than public tokens!
    Arguments:
        None
    Returns:
        str[]: list of public datasets
    """
    return list(self.get_public_datasets_and_tokens().keys())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_public_datasets_and_tokens">
    <p>def <span class="ident">get_public_datasets_and_tokens</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>&emsp;&emsp;&emsp;&emsp;<b>NOTE</b>: VERY SLOW!<br />
Get a dictionary relating key:dataset to value:[tokens] that rely<br />
on that dataset.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>None</b></p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>dict</b>: relating key:dataset to value:[tokens]</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_public_datasets_and_tokens', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_public_datasets_and_tokens" class="source">
    <pre><code>def get_public_datasets_and_tokens(self):
    """
    NOTE: VERY SLOW!
    Get a dictionary relating key:dataset to value:[tokens] that rely
    on that dataset.
    Arguments:
        None
    Returns:
        dict: relating key:dataset to value:[tokens]
    """
    datasets = {}
    tokens = self.get_public_tokens()
    for t in tokens:
        dataset = self.get_token_dataset(t)
        if dataset in datasets:
            datasets[dataset].append(t)
        else:
            datasets[dataset] = [t]
    return datasets
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_public_tokens">
    <p>def <span class="ident">get_public_tokens</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get a list of public tokens available on this server.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>None</b></p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>str[]</b>: list of public tokens</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_public_tokens', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_public_tokens" class="source">
    <pre><code>def get_public_tokens(self):
    """
    Get a list of public tokens available on this server.
    Arguments:
        None
    Returns:
        str[]: list of public tokens
    """
    r = requests.get(self.url() + "public_tokens/")
    return r.json()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_ramon">
    <p>def <span class="ident">get_ramon</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Download a RAMON object by ID.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: Project to use<br />
&emsp;&emsp;&emsp;&emsp;<b>channel (str)</b>: The channel to use<br />
&emsp;&emsp;&emsp;&emsp;<b>ids (int, str, int[], str[])</b>: The IDs of a RAMON object to gather.<br />
        Can be int (3), string ("3"), int[] ([3, 4, 5]), or string<br />
        (["3", "4", "5"]).<br />
&emsp;&emsp;&emsp;&emsp;<b>resolution (int : None)</b>: Resolution. Defaults to the most granular<br />
        resolution (0 for now)<br />
&emsp;&emsp;&emsp;&emsp;<b>include_cutout (bool : False)</b>:  If True, r.cutout is populated<br />
&emsp;&emsp;&emsp;&emsp;<b>sieve (function : None)</b>: A function that accepts a single ramon<br />
        and returns True or False depending on whether you want that<br />
        ramon object to be included in your response or not.<br />
        For example,<br />
<code>def is_even_id(ramon):
            return ramon.id % 2 == 0</code><br />
        You can then pass this to get_ramon like this:<br />
<code>ndio.remote.neurodata.get_ramon( . . . , sieve=is_even_id)</code><br />
&emsp;&emsp;&emsp;&emsp;<b>batch_size (int : 100)</b>: The amount of RAMON objects to download at<br />
        a time. If this is greater than 100, we anticipate things going<br />
        very poorly for you. So if you set it &lt;100, ndio will use it.<br />
        If &gt;=100, set it to 100.</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>ndio.ramon.RAMON[]</b>: A list of returned RAMON objects.</p>
<h2 style='font-size:125% !important'>Raises</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>RemoteDataNotFoundError</b>: If the requested ids cannot be found.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_ramon', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_ramon" class="source">
    <pre><code>@_check_token
def get_ramon(self, token, channel, ids, resolution=0,
              include_cutout=False, sieve=None, batch_size=100):
    """
    Download a RAMON object by ID.
    Arguments:
        token (str): Project to use
        channel (str): The channel to use
        ids (int, str, int[], str[]): The IDs of a RAMON object to gather.
            Can be int (3), string ("3"), int[] ([3, 4, 5]), or string
            (["3", "4", "5"]).
        resolution (int : None): Resolution. Defaults to the most granular
            resolution (0 for now)
        include_cutout (bool : False):  If True, r.cutout is populated
        sieve (function : None): A function that accepts a single ramon
            and returns True or False depending on whether you want that
            ramon object to be included in your response or not.
            For example,
            ```
            def is_even_id(ramon):
                return ramon.id % 2 == 0
            ```
            You can then pass this to get_ramon like this:
            ```
            ndio.remote.neurodata.get_ramon( . . . , sieve=is_even_id)
            ```
        batch_size (int : 100): The amount of RAMON objects to download at
            a time. If this is greater than 100, we anticipate things going
            very poorly for you. So if you set it <100, ndio will use it.
            If >=100, set it to 100.
    Returns:
        ndio.ramon.RAMON[]: A list of returned RAMON objects.
    Raises:
        RemoteDataNotFoundError: If the requested ids cannot be found.
    """
    b_size = min(100, batch_size)
    _return_first_only = False
    if type(ids) is not list:
        _return_first_only = True
        ids = [ids]
    ids = [str(i) for i in ids]
    rs = []
    id_batches = [ids[i:i+b_size] for i in range(0, len(ids), b_size)]
    for batch in id_batches:
        rs.extend(self._get_ramon_batch(token, channel, batch, resolution))
    rs = self._filter_ramon(rs, sieve)
            # if 'cutout' not in dir(ramon):
            #     return ramon
    if include_cutout:
        rs = [self._add_ramon_cutout(token, channel, r, resolution)
              for r in rs]
    if _return_first_only:
        return rs[0]
    return sorted(rs, key=lambda x: ids.index(x.id))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_ramon_bounding_box">
    <p>def <span class="ident">get_ramon_bounding_box</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the bounding box for a RAMON object (specified by ID).</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: Project to use<br />
&emsp;&emsp;&emsp;&emsp;<b>channel (str)</b>: Channel to use<br />
&emsp;&emsp;&emsp;&emsp;<b>r_id (int)</b>: Which ID to get a bounding box<br />
&emsp;&emsp;&emsp;&emsp;<b>resolution (int : 0)</b>: The resolution at which to download</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>(x_start, x_stop, y_start, y_stop, z_start, z_stop)</b>: ints</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_ramon_bounding_box', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_ramon_bounding_box" class="source">
    <pre><code>@_check_token
def get_ramon_bounding_box(self, token, channel, r_id, resolution=0):
    """
    Get the bounding box for a RAMON object (specified by ID).
    Arguments:
        token (str): Project to use
        channel (str): Channel to use
        r_id (int): Which ID to get a bounding box
        resolution (int : 0): The resolution at which to download
    Returns:
        (x_start, x_stop, y_start, y_stop, z_start, z_stop): ints
    """
    url = self.url('{}/{}/{}/boundingbox/{}/'.format(token, channel,
                                                     r_id, resolution))
    r_id = str(r_id)
    res = requests.get(url)
    if res.status_code != 200:
        rt = self.get_ramon_metadata(token, channel, r_id)[r_id]['type']
        if rt in ['neuron']:
            raise ValueError("ID {} is of type '{}'".format(r_id, rt))
        raise RemoteDataNotFoundError("No such ID {}".format(r_id))
    with tempfile.NamedTemporaryFile() as tmpfile:
        tmpfile.write(res.content)
        tmpfile.seek(0)
        h5file = h5py.File(tmpfile.name, "r")
        origin = h5file["{}/XYZOFFSET".format(r_id)][()]
        size = h5file["{}/XYZDIMENSION".format(r_id)][()]
        return (origin[0], origin[0] + size[0],
                origin[1], origin[1] + size[1],
                origin[2], origin[2] + size[2])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_ramon_ids">
    <p>def <span class="ident">get_ramon_ids</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of all IDs available for download from this token and<br />
channel.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: Project to use<br />
&emsp;&emsp;&emsp;&emsp;<b>channel (str)</b>: Channel to use<br />
&emsp;&emsp;&emsp;&emsp;<b>ramon_type (int : None)</b>: Optional. If set, filters IDs and only<br />
        returns those of RAMON objects of the requested type.</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>int[]</b>: A list of the ids of the returned RAMON objects</p>
<h2 style='font-size:125% !important'>Raises</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>RemoteDataNotFoundError</b>: If the channel or token is not found</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_ramon_ids', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_ramon_ids" class="source">
    <pre><code>@_check_token
def get_ramon_ids(self, token, channel, ramon_type=None):
    """
    Return a list of all IDs available for download from this token and
    channel.
    Arguments:
        token (str): Project to use
        channel (str): Channel to use
        ramon_type (int : None): Optional. If set, filters IDs and only
            returns those of RAMON objects of the requested type.
    Returns:
        int[]: A list of the ids of the returned RAMON objects
    Raises:
        RemoteDataNotFoundError: If the channel or token is not found
    """
    url = self.url("{}/{}/query/".format(token, channel))
    if ramon_type is not None:
        # User is requesting a specific ramon_type.
        if type(ramon_type) is not int:
            ramon_type = ramon.AnnotationType.get_int(ramon_type)
        url += "type/{}/".format(str(ramon_type))
    req = requests.get(url)
    if req.status_code is not 200:
        raise RemoteDataNotFoundError('No query results for token {}.'
                                      .format(token))
    else:
        with tempfile.NamedTemporaryFile() as tmpfile:
            tmpfile.write(req.content)
            tmpfile.seek(0)
            h5file = h5py.File(tmpfile.name, "r")
            if 'ANNOIDS' not in h5file:
                return []
            return [i for i in h5file['ANNOIDS']]
        raise IOError("Could not successfully mock HDF5 file for parsing.")
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_ramon_metadata">
    <p>def <span class="ident">get_ramon_metadata</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Download a RAMON object by ID. <code>anno_id</code> can be a string <code>"123"</code>, an<br />
int <code>123</code>, an array of ints <code>[123, 234, 345]</code>, an array of strings<br />
<code>["123", "234", "345"]</code>, or a comma-separated string list<br />
<code>"123,234,345"</code>.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: Project to use<br />
&emsp;&emsp;&emsp;&emsp;<b>channel (str)</b>: The channel to use<br />
&emsp;&emsp;&emsp;&emsp;<b>anno_id</b>: An int, a str, or a list of ids to gather</p>
<h2 style='font-size:125% !important'>Returns</h2>

<pre><code>JSON. If you pass a single id in str or int, returns a single datum
If you pass a list of int or str or a comma-separated string, will
return a dict with keys from the list and the values are the JSON
returned from the server.
</code></pre>
<h2 style='font-size:125% !important'>Raises</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>RemoteDataNotFoundError</b>: If the data cannot be found on the Remote</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_ramon_metadata', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_ramon_metadata" class="source">
    <pre><code>@_check_token
def get_ramon_metadata(self, token, channel, anno_id):
    """
    Download a RAMON object by ID. `anno_id` can be a string `"123"`, an
    int `123`, an array of ints `[123, 234, 345]`, an array of strings
    `["123", "234", "345"]`, or a comma-separated string list
    `"123,234,345"`.
    Arguments:
        token (str): Project to use
        channel (str): The channel to use
        anno_id: An int, a str, or a list of ids to gather
    Returns:
        JSON. If you pass a single id in str or int, returns a single datum
        If you pass a list of int or str or a comma-separated string, will
        return a dict with keys from the list and the values are the JSON
        returned from the server.
    Raises:
        RemoteDataNotFoundError: If the data cannot be found on the Remote
    """
    if type(anno_id) in [int, numpy.uint32]:
        # there's just one ID to download
        return self._get_single_ramon_metadata(token, channel,
                                               str(anno_id))
    elif type(anno_id) is str:
        # either "id" or "id,id,id":
        if (len(anno_id.split(',')) > 1):
            results = {}
            for i in anno_id.split(','):
                results[i] = self._get_single_ramon_metadata(
                    token, channel, anno_id.strip()
                )
            return results
        else:
            # "id"
            return self._get_single_ramon_metadata(token, channel,
                                                   anno_id.strip())
    elif type(anno_id) is list:
        # [id, id] or ['id', 'id']
        results = []
        for i in anno_id:
            results.append(self._get_single_ramon_metadata(token, channel,
                                                           str(i)))
        return results
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_subvolumes">
    <p>def <span class="ident">get_subvolumes</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of subvolumes taken from LIMS, if available.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: The token to read from in LIMS</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>dict</b>: or None if unavailable</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_subvolumes', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_subvolumes" class="source">
    <pre><code>@_check_token
def get_subvolumes(self, token):
    """
    Return a list of subvolumes taken from LIMS, if available.
    Arguments:
        token (str): The token to read from in LIMS
    Returns:
        dict: or None if unavailable
    """
    md = self.get_metadata(token)['metadata']
    if 'subvolumes' in md:
        return md['subvolumes']
    else:
        return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_token_dataset">
    <p>def <span class="ident">get_token_dataset</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the dataset for a given token.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: The token to inspect</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>str</b>: The name of the dataset</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_token_dataset', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_token_dataset" class="source">
    <pre><code>@_check_token
def get_token_dataset(self, token):
    """
    Get the dataset for a given token.
    Arguments:
        token (str): The token to inspect
    Returns:
        str: The name of the dataset
    """
    return self.get_proj_info(token)['dataset']['description']
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_volume">
    <p>def <span class="ident">get_volume</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Get a RAMONVolume volumetric cutout from the neurodata server.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: Token to identify data to download<br />
&emsp;&emsp;&emsp;&emsp;<b>channel (str)</b>: Channel<br />
&emsp;&emsp;&emsp;&emsp;<b>resolution (int)</b>: Resolution level<br />
&emsp;&emsp;&emsp;&emsp;<b>Q_start (int)</b>: The lower bound of dimension 'Q'<br />
&emsp;&emsp;&emsp;&emsp;<b>Q_stop (int)</b>: The upper bound of dimension 'Q'<br />
&emsp;&emsp;&emsp;&emsp;<b>block_size (int[3])</b>: Block size of this dataset<br />
&emsp;&emsp;&emsp;&emsp;<b>neariso (bool : False)</b>: Passes the 'neariso' param to the cutout.<br />
        If you don't know what this means, ignore it!</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>ndio.ramon.RAMONVolume</b>: Downloaded data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_volume', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_volume" class="source">
    <pre><code>@_check_token
def get_volume(self, token, channel,
               x_start, x_stop,
               y_start, y_stop,
               z_start, z_stop,
               resolution=1,
               block_size=DEFAULT_BLOCK_SIZE,
               neariso=False):
    """
    Get a RAMONVolume volumetric cutout from the neurodata server.
    Arguments:
        token (str): Token to identify data to download
        channel (str): Channel
        resolution (int): Resolution level
        Q_start (int): The lower bound of dimension 'Q'
        Q_stop (int): The upper bound of dimension 'Q'
        block_size (int[3]): Block size of this dataset
        neariso (bool : False): Passes the 'neariso' param to the cutout.
            If you don't know what this means, ignore it!
    Returns:
        ndio.ramon.RAMONVolume: Downloaded data.
    """
    size = (x_stop-x_start)*(y_stop-y_start)*(z_stop-z_start)
    volume = ramon.RAMONVolume()
    volume.xyz_offset = [x_start, y_start, z_start]
    volume.resolution = resolution
    volume.cutout = self.get_cutout(token, channel, x_start,
                                    x_stop, y_start, y_stop,
                                    z_start, z_stop,
                                    resolution=resolution,
                                    block_size=block_size,
                                    neariso=neariso)
    return volume
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.get_xy_slice">
    <p>def <span class="ident">get_xy_slice</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a binary-encoded, decompressed 2d image. You should<br />
specify a 'token' and 'channel' pair.  For image data, users<br />
should use the channel 'image.'</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: Token to identify data to download<br />
&emsp;&emsp;&emsp;&emsp;<b>channel (str)</b>: Channel<br />
&emsp;&emsp;&emsp;&emsp;<b>resolution (int)</b>: Resolution level<br />
    Q_start (int):` The lower bound of dimension 'Q'<br />
&emsp;&emsp;&emsp;&emsp;<b>Q_stop (int)</b>: The upper bound of dimension 'Q'<br />
&emsp;&emsp;&emsp;&emsp;<b>z_index (int)</b>: The z-slice to image</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>str</b>: binary image data</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.get_xy_slice', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.get_xy_slice" class="source">
    <pre><code>@_check_token
def get_xy_slice(self, token, channel,
                 x_start, x_stop,
                 y_start, y_stop,
                 z_index,
                 resolution=0):
    """
    Return a binary-encoded, decompressed 2d image. You should
    specify a 'token' and 'channel' pair.  For image data, users
    should use the channel 'image.'
    Arguments:
        token (str): Token to identify data to download
        channel (str): Channel
        resolution (int): Resolution level
        Q_start (int):` The lower bound of dimension 'Q'
        Q_stop (int): The upper bound of dimension 'Q'
        z_index (int): The z-slice to image
    Returns:
        str: binary image data
    """
    vol = self.get_cutout(token, channel, x_start, x_stop, y_start,
                          y_stop, z_index, z_index+1, resolution)
    vol = numpy.squeeze(vol)  # 3D volume to 2D slice
    return vol
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.merge_ids">
    <p>def <span class="ident">merge_ids</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Call the restful endpoint to merge two RAMON objects into one.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: The token to inspect<br />
&emsp;&emsp;&emsp;&emsp;<b>channel (str)</b>: The channel to inspect<br />
&emsp;&emsp;&emsp;&emsp;<b>ids (int[])</b>: the list of the IDs to merge<br />
&emsp;&emsp;&emsp;&emsp;<b>delete (bool : False)</b>: Whether to delete after merging.</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>json</b>: The ID as returned by ndstore</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.merge_ids', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.merge_ids" class="source">
    <pre><code>@_check_token
def merge_ids(self, token, channel, ids, delete=False):
    """
    Call the restful endpoint to merge two RAMON objects into one.
    Arguments:
        token (str): The token to inspect
        channel (str): The channel to inspect
        ids (int[]): the list of the IDs to merge
        delete (bool : False): Whether to delete after merging.
    Returns:
        json: The ID as returned by ndstore
    """
    req = requests.get(self.url() + "/merge/{}/"
                       .format(','.join([str(i) for i in ids])))
    if req.status_code is not 200:
        raise RemoteDataUploadError('Could not merge ids {}'.format(
                                    ','.join([str(i) for i in ids])))
    if delete:
        self.delete_ramon(token, channel, ids[1:])
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.meta_url">
    <p>def <span class="ident">meta_url</span>(</p><p>self, suffix=&#39;&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a constructed URL, appending an optional suffix (uri path),<br />
for the metadata server. (Should be temporary, until the LIMS shim<br />
is fixed.)</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>suffix (str : "")</b>: The suffix to append to the end of the URL</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>str</b>: The complete URL</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.meta_url', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.meta_url" class="source">
    <pre><code>def meta_url(self, suffix=""):
    """
    Return a constructed URL, appending an optional suffix (uri path),
    for the metadata server. (Should be temporary, until the LIMS shim
    is fixed.)
    Arguments:
        suffix (str : ""): The suffix to append to the end of the URL
    Returns:
        str: The complete URL
    """
    return self.meta_protocol + "://" + self.meta_root + suffix
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.ping">
    <p>def <span class="ident">ping</span>(</p><p>self, suffix=&#39;public_tokens/&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the status-code of the API (estimated using the public-tokens<br />
lookup page).</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>suffix (str : 'public_tokens/')</b>: The url endpoint to check</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>int</b>: status code</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.ping', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.ping" class="source">
    <pre><code>def ping(self, suffix='public_tokens/'):
    """
    Return the status-code of the API (estimated using the public-tokens
    lookup page).
    Arguments:
        suffix (str : 'public_tokens/'): The url endpoint to check
    Returns:
        int: status code
    """
    return super(neurodata, self).ping(suffix)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.post_cutout">
    <p>def <span class="ident">post_cutout</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Post a cutout to the server.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<pre><code>token (str)
channel (str)
x_start (int)
y_start (int)
z_start (int)
</code></pre>
<p>&emsp;&emsp;&emsp;&emsp;<b>data (numpy.ndarray)</b>: A numpy array of data. Pass in (x, y, z)<br />
&emsp;&emsp;&emsp;&emsp;<b>resolution (int : 0)</b>: Resolution at which to insert the data</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>bool</b>: True on success</p>
<h2 style='font-size:125% !important'>Raises</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>RemoteDataUploadError</b>: if there's an issue during upload.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.post_cutout', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.post_cutout" class="source">
    <pre><code>@_check_token
def post_cutout(self, token, channel,
                x_start,
                y_start,
                z_start,
                data,
                resolution=0):
    """
    Post a cutout to the server.
    Arguments:
        token (str)
        channel (str)
        x_start (int)
        y_start (int)
        z_start (int)
        data (numpy.ndarray): A numpy array of data. Pass in (x, y, z)
        resolution (int : 0): Resolution at which to insert the data
    Returns:
        bool: True on success
    Raises:
        RemoteDataUploadError: if there's an issue during upload.
    """
    datatype = self.get_proj_info(token)['channels'][channel]['datatype']
    if data.dtype.name != datatype:
        data = data.astype(datatype)
    data = numpy.rollaxis(data, 1)
    data = numpy.rollaxis(data, 2)
    if six.PY3 or data.nbytes > 1.5e9:
        ul_func = self._post_cutout_no_chunking_npz
    else:
        ul_func = self._post_cutout_no_chunking_blosc
    if data.size < self._chunk_threshold:
        return ul_func(token, channel, x_start,
                       y_start, z_start, data,
                       resolution)
    return self._post_cutout_with_chunking(token, channel,
                                           x_start, y_start, z_start, data,
                                           resolution, ul_func)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.post_ramon">
    <p>def <span class="ident">post_ramon</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Posts a RAMON object to the Remote.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: Project to use<br />
&emsp;&emsp;&emsp;&emsp;<b>channel (str)</b>: The channel to use<br />
&emsp;&emsp;&emsp;&emsp;<b>r (RAMON or RAMON[])</b>: The annotation(s) to upload<br />
&emsp;&emsp;&emsp;&emsp;<b>batch_size (int : 100)</b>: The number of RAMONs to post simultaneously<br />
        at maximum in one file. If len(r) &gt; batch_size, the batch will<br />
        be split and uploaded automatically. Must be less than 100.</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>bool</b>: Success = True</p>
<p>Throws:<br />
&emsp;&emsp;&emsp;&emsp;<b>RemoteDataUploadError</b>: if something goes wrong</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.post_ramon', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.post_ramon" class="source">
    <pre><code>@_check_token
def post_ramon(self, token, channel, r, batch_size=100):
    """
    Posts a RAMON object to the Remote.
    Arguments:
        token (str): Project to use
        channel (str): The channel to use
        r (RAMON or RAMON[]): The annotation(s) to upload
        batch_size (int : 100): The number of RAMONs to post simultaneously
            at maximum in one file. If len(r) > batch_size, the batch will
            be split and uploaded automatically. Must be less than 100.
    Returns:
        bool: Success = True
    Throws:
        RemoteDataUploadError: if something goes wrong
    """
    # Max out batch-size at 100.
    b_size = min(100, batch_size)
    # Coerce incoming IDs to a list.
    if type(r) is not list:
        r = [r]
    # If there are too many to fit in one batch, split here and call this
    # function recursively.
    if len(r) > batch_size:
        batches = [r[i:i+b_size] for i in range(0, len(r), b_size)]
        for batch in batches:
            self.post_ramon(token, channel, batch, b_size)
        return
    with tempfile.NamedTemporaryFile(delete=False) as tmpfile:
        for i in r:
            tmpfile = ramon.to_hdf5(i, tmpfile)
        url = self.url("{}/{}/overwrite/".format(token, channel))
        req = urllib2.Request(url, tmpfile.read())
        res = urllib2.urlopen(req)
        if res.code != 200:
            raise RemoteDataUploadError('[{}] Could not upload {}'
                                        .format(res.code, str(r)))
        rets = res.read()
        if six.PY3:
            rets = rets.decode()
        return_ids = [int(rid) for rid in rets.split(',')]
        # Now post the cutout separately:
        for ri in r:
            if 'cutout' in dir(ri) and ri.cutout is not None:
                orig = ri.xyz_offset
                self.post_cutout(token, channel,
                                 orig[0], orig[1], orig[2],
                                 ri.cutout, resolution=r.resolution)
        return return_ids
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.propagate">
    <p>def <span class="ident">propagate</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Kick off the propagate function on the remote server.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: The token to propagate<br />
&emsp;&emsp;&emsp;&emsp;<b>channel (str)</b>: The channel to propagate</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>boolean</b>: Success</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.propagate', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.propagate" class="source">
    <pre><code>@_check_token
def propagate(self, token, channel):
    """
    Kick off the propagate function on the remote server.
    Arguments:
        token (str): The token to propagate
        channel (str): The channel to propagate
    Returns:
        boolean: Success
    """
    if self.get_propagate_status(token, channel) is not 0:
        return
    url = self.url('{}/{}/setPropagate/1/'.format(token, channel))
    req = requests.get(url)
    if req.status_code is not 200:
        raise RemoteDataUploadError('Propagate fail: {}'.format(req.text))
    return True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.reserve_ids">
    <p>def <span class="ident">reserve_ids</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Requests a list of next-available-IDs from the server.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>quantity (int)</b>: The number of IDs to reserve</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>int[quantity]</b>: List of IDs you've been granted</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.reserve_ids', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.reserve_ids" class="source">
    <pre><code>@_check_token
def reserve_ids(self, token, channel, quantity):
    """
    Requests a list of next-available-IDs from the server.
    Arguments:
        quantity (int): The number of IDs to reserve
    Returns:
        int[quantity]: List of IDs you've been granted
    """
    quantity = str(quantity)
    url = self.url("{}/{}/reserve/{}/".format(token, channel, quantity))
    req = requests.get(url)
    if req.status_code is not 200:
        raise RemoteDataNotFoundError('Invalid req: ' + req.status_code)
    out = req.json()
    return [out[0] + i for i in range(out[1])]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.set_metadata">
    <p>def <span class="ident">set_metadata</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Insert new metadata into the OCP metadata database.</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>token (str)</b>: Token of the datum to set<br />
&emsp;&emsp;&emsp;&emsp;<b>data (str)</b>: A dictionary to insert as metadata. Include <code>secret</code>.</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>json</b>: Info of the inserted ID (convenience) or an error message.</p>
<p>Throws:<br />
&emsp;&emsp;&emsp;&emsp;<b>RemoteDataUploadError</b>: If the token is already populated, or if<br />
        there is an issue with your specified <code>secret</code> key.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.set_metadata', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.set_metadata" class="source">
    <pre><code>@_check_token
def set_metadata(self, token, data):
    """
    Insert new metadata into the OCP metadata database.
    Arguments:
        token (str): Token of the datum to set
        data (str): A dictionary to insert as metadata. Include `secret`.
    Returns:
        json: Info of the inserted ID (convenience) or an error message.
    Throws:
        RemoteDataUploadError: If the token is already populated, or if
            there is an issue with your specified `secret` key.
    """
    req = requests.post(self.meta_url("metadata/ocp/set/" + token),
                        json=data)
    if req.status_code != 200:
        raise RemoteDataUploadError(
            "Could not upload metadata: " + req.json()['message']
        )
    return req.json()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="ndio.remote.neurodata.neurodata.url">
    <p>def <span class="ident">url</span>(</p><p>self, suffix=&#39;&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a constructed URL, appending an optional suffix (uri path).</p>
<h2 style='font-size:125% !important'>Arguments</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>suffix (str : "")</b>: The suffix to append to the end of the URL</p>
<h2 style='font-size:125% !important'>Returns</h2>

<p>&emsp;&emsp;&emsp;&emsp;<b>str</b>: The complete URL</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-ndio.remote.neurodata.neurodata.url', this);">Show source &equiv;</a></p>
  <div id="source-ndio.remote.neurodata.neurodata.url" class="source">
    <pre><code>def url(self, suffix=""):
    """
    Return a constructed URL, appending an optional suffix (uri path).
    Arguments:
        suffix (str : ""): The suffix to append to the end of the URL
    Returns:
        str: The complete URL
    """
    return super(neurodata, self).url('{}/ca/'.format(self._ext) + suffix)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="ndio.remote.neurodata.neurodata.meta_protocol" class="name">var <span class="ident">meta_protocol</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="ndio.remote.neurodata.neurodata.meta_root" class="name">var <span class="ident">meta_root</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
